{"version":3,"file":"assets/workers/resampling.worker.min.js","mappings":"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","sources":["webpack://dwv/./src/math/vector.js","webpack://dwv/./src/math/point.js","webpack://dwv/./src/math/index.js","webpack://dwv/./src/utils/logger.js","webpack://dwv/./src/math/matrix.js","webpack://dwv/./src/dicom/dicomParser.js","webpack://dwv/./src/image/resamplingFilter.js","webpack://dwv/./src/image/resampling.worker.js"],"sourcesContent":["/**\n * Immutable 3D vector.\n */\nexport class Vector3D {\n\n  /**\n   * X coordinate.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y coordinate.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * Z coordinate.\n   *\n   * @type {number}\n   */\n  #z;\n\n  /**\n   * @param {number} x The X component of the vector.\n   * @param {number} y The Y component of the vector.\n   * @param {number} z The Z component of the vector.\n   */\n  constructor(x, y, z) {\n    this.#x = x;\n    this.#y = y;\n    this.#z = z;\n  }\n\n  /**\n   * Get the X component of the vector.\n   *\n   * @returns {number} The X component of the vector.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y component of the vector.\n   *\n   * @returns {number} The Y component of the vector.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the Z component of the vector.\n   *\n   * @returns {number} The Z component of the vector.\n   */\n  getZ() {\n    return this.#z;\n  }\n\n  /**\n   * Check for Vector3D equality.\n   *\n   * @param {Vector3D} rhs The other vector to compare to.\n   * @returns {boolean} True if both vectors are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY() &&\n      this.#z === rhs.getZ();\n  }\n\n  /**\n   * Get a string representation of the Vector3D.\n   *\n   * @returns {string} The vector as a string.\n   */\n  toString() {\n    return '(' + this.#x +\n      ', ' + this.#y +\n      ', ' + this.#z + ')';\n  }\n\n  /**\n   * Get the norm of the vector.\n   *\n   * @returns {number} The norm.\n   */\n  norm() {\n    return Math.sqrt(\n      (this.#x * this.#x) +\n      (this.#y * this.#y) +\n      (this.#z * this.#z)\n    );\n  }\n\n  /**\n   * Get the cross product with another Vector3D, ie the\n   * vector that is perpendicular to both a and b.\n   * If both vectors are parallel, the cross product is a zero vector.\n   *\n   * Ref: {@link https://en.wikipedia.org/wiki/Cross_product}.\n   *\n   * @param {Vector3D} vector3D The input vector.\n   * @returns {Vector3D} The result vector.\n   */\n  crossProduct(vector3D) {\n    return new Vector3D(\n      (this.#y * vector3D.getZ()) - (vector3D.getY() * this.#z),\n      (this.#z * vector3D.getX()) - (vector3D.getZ() * this.#x),\n      (this.#x * vector3D.getY()) - (vector3D.getX() * this.#y));\n  }\n\n  /**\n   * Get the dot product with another Vector3D.\n   *\n   * Ref: {@link https://en.wikipedia.org/wiki/Dot_product}.\n   *\n   * @param {Vector3D} vector3D The input vector.\n   * @returns {number} The dot product.\n   */\n  dotProduct(vector3D) {\n    return (this.#x * vector3D.getX()) +\n      (this.#y * vector3D.getY()) +\n      (this.#z * vector3D.getZ());\n  }\n\n  /**\n   * Is this vector codirectional to an input one.\n   *\n   * @param {Vector3D} vector3D The vector to test.\n   * @returns {boolean} True if codirectional, false is opposite.\n   */\n  isCodirectional(vector3D) {\n    // a.dot(b) = ||a|| * ||b|| * cos(theta)\n    // (https://en.wikipedia.org/wiki/Dot_product#Geometric_definition)\n    // -> the sign of the dot product depends on the cosinus of\n    //    the angle between the vectors\n    //   -> >0 => vectors are codirectional\n    //   -> <0 => vectors are opposite\n    return this.dotProduct(vector3D) > 0;\n  }\n\n} // Vector3D class","import {isSimilar} from './matrix.js';\nimport {Vector3D} from './vector.js';\n\n/**\n * Immutable 2D point.\n */\nexport class Point2D {\n\n  /**\n   * X position.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y position.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * @param {number} x The X coordinate for the point.\n   * @param {number} y The Y coordinate for the point.\n   */\n  constructor(x, y) {\n    this.#x = x;\n    this.#y = y;\n  }\n\n  /**\n   * Get the X position of the point.\n   *\n   * @returns {number} The X position of the point.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y position of the point.\n   *\n   * @returns {number} The Y position of the point.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return [this.#x, this.#y];\n  }\n\n  /**\n   * Get the centroid of the point, ie itself.\n   *\n   * @returns {Point2D} The centroid point.\n   */\n  getCentroid() {\n    return this;\n  }\n\n  /**\n   * Check for Point2D equality.\n   *\n   * @param {Point2D} rhs The other point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      typeof rhs !== 'undefined' &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY();\n  }\n\n  /**\n   * Get a string representation of the Point2D.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#x + ', ' + this.#y + ')';\n  }\n\n  /**\n   * Get the distance to another Point2D.\n   *\n   * @param {Point2D} point2D The input point.\n   * @returns {number} Ths distance to the input point.\n   */\n  getDistance(point2D) {\n    const dx = this.#x - point2D.getX();\n    const dy = this.#y - point2D.getY();\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n} // Point2D class\n\n/**\n * Immutable 3D point.\n */\nexport class Point3D {\n\n  /**\n   * X position.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y position.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * Z position.\n   *\n   * @type {number}\n   */\n  #z;\n\n  /**\n   * @param {number} x The X coordinate for the point.\n   * @param {number} y The Y coordinate for the point.\n   * @param {number} z The Z coordinate for the point.\n   */\n  constructor(x, y, z) {\n    this.#x = x;\n    this.#y = y;\n    this.#z = z;\n  }\n\n  /**\n   * Get the X position of the point.\n   *\n   * @returns {number} The X position of the point.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y position of the point.\n   *\n   * @returns {number} The Y position of the point.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the Z position of the point.\n   *\n   * @returns {number} The Z position of the point.\n   */\n  getZ() {\n    return this.#z;\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return [this.#x, this.#y, this.#z];\n  }\n\n  /**\n   * Check for Point3D equality.\n   *\n   * @param {Point3D} rhs The other point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY() &&\n      this.#z === rhs.getZ();\n  }\n\n  /**\n   * Check for Point3D similarity.\n   *\n   * @param {Point3D} rhs The other point to compare to.\n   * @param {number} [tol] Optional number comparison tolerance,\n   *   defaults to Number.EPSILON.\n   * @returns {boolean} True if both points are similar.\n   */\n  isSimilar(rhs, tol) {\n    return rhs !== null &&\n      isSimilar(this.#x, rhs.getX(), tol) &&\n      isSimilar(this.#y, rhs.getY(), tol) &&\n      isSimilar(this.#z, rhs.getZ(), tol);\n  }\n\n  /**\n   * Get a string representation of the Point3D.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#x +\n      ', ' + this.#y +\n      ', ' + this.#z + ')';\n  }\n\n  /**\n   * Get the distance to another Point3D.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {number} Ths distance to the input point.\n   */\n  getDistance(point3D) {\n    return Math.sqrt(this.#getSquaredDistance(point3D));\n  }\n\n  /**\n   * Get the square of the distance between this and\n   * an input point. Used for sorting.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {number} The square of the distance.\n   */\n  #getSquaredDistance(point3D) {\n    const dx = this.#x - point3D.getX();\n    const dy = this.#y - point3D.getY();\n    const dz = this.#z - point3D.getZ();\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  /**\n   * Get the closest point to this in a Point3D list.\n   *\n   * @param {Point3D[]} pointList The list to check.\n   * @returns {number} The index of the closest point in the input list.\n   */\n  getClosest(pointList) {\n    let minIndex = 0;\n    // the order between squared distances and distances is the same\n    let minDist = this.#getSquaredDistance(pointList[minIndex]);\n    for (let i = 0; i < pointList.length; ++i) {\n      const dist = this.#getSquaredDistance(pointList[i]);\n      if (dist < minDist) {\n        minIndex = i;\n        minDist = dist;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * Get the difference to another Point3D.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {Vector3D} The 3D vector from the input point to this one.\n   */\n  minus(point3D) {\n    return new Vector3D(\n      (this.#x - point3D.getX()),\n      (this.#y - point3D.getY()),\n      (this.#z - point3D.getZ()));\n  }\n\n} // Point3D class\n\n/**\n * Get an array find callback for an equal input point.\n *\n * @param {Point3D} point The point to compare to.\n * @returns {Function} A function that compares, using `equals`,\n *   its input point to the one given as input to this function.\n */\nexport function getEqualPoint3DFunction(point) {\n  return function (element) {\n    return element.equals(point);\n  };\n}\n\n/**\n * Immutable point.\n * Warning: the input array is NOT cloned, modifying it will\n *  modify the point values.\n */\nexport class Point {\n\n  /**\n   * Point values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * @param {number[]} values The point values.\n   */\n  constructor(values) {\n    if (!values || typeof values === 'undefined') {\n      throw new Error('Cannot create point with no values.');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot create point with empty values.');\n    }\n    const valueCheck = function (val) {\n      return !isNaN(val);\n    };\n    if (!values.every(valueCheck)) {\n      throw new Error('Cannot create point with non number values.');\n    }\n    this.#values = values;\n  }\n\n  /**\n   * Get the point value at the given array index.\n   *\n   * @param {number} i The index to get.\n   * @returns {number} The value.\n   */\n  get(i) {\n    return this.#values[i];\n  }\n\n  /**\n   * Get the length of the point.\n   *\n   * @returns {number} The length.\n   */\n  length() {\n    return this.#values.length;\n  }\n\n  /**\n   * Get a string representation of the point.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#values.toString() + ')';\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n  /**\n   * Check if the input point can be compared to this one.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {boolean} True if both points are comparable.\n   */\n  canCompare(rhs) {\n    // check input\n    if (!rhs) {\n      return false;\n    }\n    // check length\n    if (this.length() !== rhs.length()) {\n      return false;\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Check for Point equality.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return false;\n    }\n    // check values\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        return false;\n      }\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Compare points and return different dimensions.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {number[]} The list of different dimensions.\n   */\n  compare(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // check values\n    const diffDims = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        diffDims.push(i);\n      }\n    }\n    return diffDims;\n  }\n\n  /**\n   * Get the 3D part of this point.\n   *\n   * @returns {Point3D} The Point3D.\n   */\n  get3D() {\n    return new Point3D(this.get(0), this.get(1), this.get(2));\n  }\n\n  /**\n   * Add another point to this one.\n   *\n   * @param {Point} rhs The point to add.\n   * @returns {Point} The point representing the sum of both points.\n   */\n  add(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    const values = [];\n    const values0 = this.getValues();\n    const values1 = rhs.getValues();\n    for (let i = 0; i < values0.length; ++i) {\n      values.push(values0[i] + values1[i]);\n    }\n    return new Point(values);\n  }\n\n  /**\n   * Merge this point with a Point3D to create a new point.\n   *\n   * @param {Point3D} rhs The Point3D to merge with.\n   * @returns {Point} The merge result.\n   */\n  mergeWith3D(rhs) {\n    const values = this.getValues();\n    values[0] = rhs.getX();\n    values[1] = rhs.getY();\n    values[2] = rhs.getZ();\n    return new Point(values);\n  }\n\n} // Point class\n","/**\n * Immutable index.\n * Warning: the input array is NOT cloned, modifying it will\n *  modify the index values.\n */\nexport class Index {\n\n  /**\n   * Index values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * @param {number[]} values The index values.\n   */\n  constructor(values) {\n    if (!values || typeof values === 'undefined') {\n      throw new Error('Cannot create index with no values.');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot create index with empty values.');\n    }\n    const valueCheck = function (val) {\n      return !isNaN(val);\n    };\n    if (!values.every(valueCheck)) {\n      throw new Error('Cannot create index with non number values.');\n    }\n    this.#values = values;\n  }\n\n  /**\n   * Get the index value at the given array index.\n   *\n   * @param {number} i The index to get.\n   * @returns {number|undefined} The value or undefined if not in range.\n   */\n  get(i) {\n    return this.#values[i];\n  }\n\n  /**\n   * Get the length of the index.\n   *\n   * @returns {number} The length.\n   */\n  length() {\n    return this.#values.length;\n  }\n\n  /**\n   * Get a string representation of the Index.\n   *\n   * @returns {string} The Index as a string.\n   */\n  toString() {\n    return '(' + this.#values.toString() + ')';\n  }\n\n  /**\n   * Get the values of this index.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n  /**\n   * Check if the input index can be compared to this one.\n   *\n   * @param {Index} rhs The index to compare to.\n   * @returns {boolean} True if both indices are comparable.\n   */\n  canCompare(rhs) {\n    // check input\n    if (!rhs) {\n      return false;\n    }\n    // check length\n    if (this.length() !== rhs.length()) {\n      return false;\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Check for Index equality.\n   *\n   * @param {Index} rhs The index to compare to.\n   * @returns {boolean} True if both indices are equal.\n   */\n  equals(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return false;\n    }\n    // check values\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        return false;\n      }\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Compare indices and return different dimensions.\n   *\n   * @param {Index} rhs The index to compare to.\n   * @returns {number[]} The list of different dimensions.\n   */\n  compare(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // check values\n    const diffDims = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        diffDims.push(i);\n      }\n    }\n    return diffDims;\n  }\n\n  /**\n   * Add another index to this one and return\n   *   the result as a new index.\n   *\n   * @param {Index} rhs The index to add.\n   * @returns {Index} The index representing the sum of both indices.\n   */\n  add(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // add values\n    const values = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      values.push(this.get(i) + rhs.get(i));\n    }\n    // seems ok!\n    return new Index(values);\n  }\n\n  /**\n   * Add the input value to this index at the given\n   *   dimension number and return the result\n   *   as a new index.\n   *\n   * @param {number} dim The dimension number.\n   * @param {number} value The value to add.\n   * @returns {Index} The result index.\n   */\n  #addToDim(dim, value) {\n    const values = this.#values.slice();\n    if (dim < values.length) {\n      values[dim] += value;\n    } else {\n      console.warn('Cannot add to given dimension: ', dim, values.length);\n    }\n    return new Index(values);\n  }\n\n  /**\n   * Increment this index by 1 at the given dimension\n   *   and return the result as a new index.\n   *\n   * @param {number} dim The dimension number.\n   * @returns {Index} The result index.\n   */\n  next(dim) {\n    return this.#addToDim(dim, 1);\n  }\n\n  /**\n   * Decrement this index by 1 at the given dimension\n   *   and return the result as a new index.\n   *\n   * @param {number} dim The dimension number.\n   * @returns {Index} The result index.\n   */\n  previous(dim) {\n    return this.#addToDim(dim, -1);\n  }\n\n  /**\n   * Get the current index with a new 2D base\n   *   and return the result as a new index.\n   *\n   * @param {number} i The new 0 index.\n   * @param {number} j The new 1 index.\n   * @returns {Index} The new index.\n   */\n  getWithNew2D(i, j) {\n    const values = [i, j];\n    for (let l = 2, lenl = this.length(); l < lenl; ++l) {\n      values.push(this.get(l));\n    }\n    return new Index(values);\n  }\n\n} // Index class\n\n/**\n * Get an index with values set to 0 and the input size.\n *\n * @param {number} size The size of the index.\n * @returns {Index} The zero index.\n */\nexport function getZeroIndex(size) {\n  const values = new Array(size);\n  values.fill(0);\n  return new Index(values);\n}\n","export const logger = {\n  /**\n   * Available log levels.\n   * Note: need to activate verbose level in\n   *   Chrome console to see DEBUG messages.\n   */\n  levels: {\n    TRACE: 0,\n    DEBUG: 1,\n    INFO: 2,\n    WARN: 3,\n    ERROR: 4\n  },\n\n  /**\n   * Logger level: default to WARN.\n   */\n  level: 3,\n\n  /**\n   * Log a trace message.\n   *\n   * @param {string} msg The message to log.\n   */\n  trace: function (msg) {\n    if (this.level <= this.levels.TRACE) {\n      console.trace(msg);\n    }\n  },\n\n  /**\n   * Log a debug message.\n   * Careful: depends on console settings.\n   *\n   * @param {string} msg The message to log.\n   */\n  debug: function (msg) {\n    if (this.level <= this.levels.DEBUG) {\n      console.debug(msg);\n    }\n  },\n\n  /**\n   * Log an info message.\n   *\n   * @param {string} msg The message to log.\n   */\n  info: function (msg) {\n    if (this.level <= this.levels.INFO) {\n      console.info(msg);\n    }\n  },\n\n  /**\n   * Log a warn message.\n   *\n   * @param {string} msg The message to log.\n   */\n  warn: function (msg) {\n    if (this.level <= this.levels.WARN) {\n      console.warn(msg);\n    }\n  },\n\n  /**\n   * Log an error message.\n   *\n   * @param {string} msg The message to log.\n   */\n  error: function (msg) {\n    if (this.level <= this.levels.ERROR) {\n      console.error(msg);\n    }\n  }\n\n}; // logger\n","import {Vector3D} from './vector.js';\nimport {Point3D} from './point.js';\nimport {Index} from './index.js';\nimport {logger} from '../utils/logger.js';\n\n// Number.EPSILON is difference between 1 and the smallest\n// floating point number greater than 1\n// -> ~2e-16\n// BIG_EPSILON -> ~2e-12\nexport const BIG_EPSILON = Number.EPSILON * 1e4;\nexport const BIG_EPSILON_EXPONENT = 12;\n// 'real world', for example when comparing positions\nexport const REAL_WORLD_EPSILON = 1e-4;\nexport const REAL_WORLD_EXPONENT = 5;\n\n/**\n * Check if two numbers are similar.\n *\n * @param {number} a The first number.\n * @param {number} b The second number.\n * @param {number} [tol] Optional comparison tolerance,\n *   defaults to Number.EPSILON.\n * @returns {boolean} True if similar.\n */\nexport function isSimilar(a, b, tol) {\n  if (typeof tol === 'undefined') {\n    tol = Number.EPSILON;\n  }\n  return Math.abs(a - b) < tol;\n}\n\n/**\n * Immutable 3x3 Matrix.\n */\nexport class Matrix33 {\n\n  /**\n   * Matrix values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * Matrix inverse, calculated at first ask.\n   *\n   * @type {Matrix33}\n   */\n  #inverse;\n\n  /**\n   * @param {number[]} values Row-major ordered 9 values.\n   */\n  constructor(values) {\n    this.#values = values;\n  }\n\n  /**\n   * Get a value of the matrix.\n   *\n   * @param {number} row The row at wich to get the value.\n   * @param {number} col The column at wich to get the value.\n   * @returns {number|undefined} The value at the position.\n   */\n  get(row, col) {\n    return this.#values[row * 3 + col];\n  }\n\n  /**\n   * Get the inverse of this matrix.\n   *\n   * @returns {Matrix33|undefined} The inverse matrix or undefined\n   *   if the determinant is zero.\n   */\n  getInverse() {\n    if (typeof this.#inverse === 'undefined') {\n      this.#inverse = getMatrixInverse(this);\n    }\n    return this.#inverse;\n  }\n\n  /**\n   * Check for Matrix33 equality.\n   *\n   * @param {Matrix33} rhs The other matrix to compare to.\n   * @returns {boolean} True if both matrices are equal.\n   */\n  equals(rhs) {\n    // TODO: add type check\n    // check values\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        if (this.get(i, j) !== rhs.get(i, j)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check for Matrix33 similarity.\n   *\n   * @param {Matrix33} rhs The other matrix to compare to.\n   * @param {number} [tol] Optional number comparison tolerance,\n   *   defaults to Number.EPSILON.\n   * @returns {boolean} True if both matrices are similar.\n   */\n  isSimilar(rhs, tol) {\n    // TODO: add type check\n    // check values\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        if (!isSimilar(this.get(i, j), rhs.get(i, j), tol)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get a string representation of the Matrix33.\n   *\n   * @returns {string} The matrix as a string.\n   */\n  toString() {\n    let str = '[';\n    for (let i = 0; i < 3; ++i) {\n      if (i !== 0) {\n        str += ', \\n ';\n      }\n      for (let j = 0; j < 3; ++j) {\n        if (j !== 0) {\n          str += ', ';\n        }\n        str += this.get(i, j);\n      }\n    }\n    str += ']';\n    return str;\n  }\n\n  /**\n   * Multiply this matrix by another.\n   *\n   * @param {Matrix33} rhs The matrix to multiply by.\n   * @returns {Matrix33} The product matrix.\n   */\n  multiply(rhs) {\n    const values = [];\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        let tmp = 0;\n        for (let k = 0; k < 3; ++k) {\n          tmp += this.get(i, k) * rhs.get(k, j);\n        }\n        values.push(tmp);\n      }\n    }\n    return new Matrix33(values);\n  }\n\n  /**\n   * Get the absolute value of this matrix.\n   *\n   * @returns {Matrix33} The result matrix.\n   */\n  getAbs() {\n    const values = [];\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        values.push(Math.abs(this.get(i, j)));\n      }\n    }\n    return new Matrix33(values);\n  }\n\n  /**\n   * Multiply this matrix by a 3D array.\n   *\n   * @param {number[]} array3D The input 3D array.\n   * @returns {number[]} The result 3D array.\n   */\n  multiplyArray3D(array3D) {\n    if (array3D.length !== 3) {\n      throw new Error('Cannot multiply 3x3 matrix with non 3D array: ' +\n        array3D.length);\n    }\n    // (no loop for speedup)\n    const a0 = array3D[0];\n    const a1 = array3D[1];\n    const a2 = array3D[2];\n    const values = new Array(3);\n    values[0] =\n      this.#values[0] * a0 +\n      this.#values[1] * a1 +\n      this.#values[2] * a2;\n    values[1] =\n      this.#values[3] * a0 +\n      this.#values[4] * a1 +\n      this.#values[5] * a2;\n    values[2] =\n      this.#values[6] * a0 +\n      this.#values[7] * a1 +\n      this.#values[8] * a2;\n    return values;\n  }\n\n  /**\n   * Multiply this matrix by a 3D typed array.\n   *\n   * @typedef {(\n   *   Uint8Array | Int8Array |\n   *   Uint16Array | Int16Array |\n   *   Uint32Array | Int32Array\n   * )} TypedArray\n   *\n   * @param {TypedArray} sourceArray The input 3D array.\n   * @param {TypedArray} outArray The array to write to.\n   */\n  multiplyTypedArray3D(sourceArray, outArray) {\n    // (no loop for speedup)\n    const a0 = sourceArray[0];\n    const a1 = sourceArray[1];\n    const a2 = sourceArray[2];\n    outArray[0] =\n      this.#values[0] * a0 +\n      this.#values[1] * a1 +\n      this.#values[2] * a2;\n    outArray[1] =\n      this.#values[3] * a0 +\n      this.#values[4] * a1 +\n      this.#values[5] * a2;\n    outArray[2] =\n      this.#values[6] * a0 +\n      this.#values[7] * a1 +\n      this.#values[8] * a2;\n  }\n\n  /**\n   * Multiply this matrix by a 3D vector.\n   *\n   * @param {Vector3D} vector3D The input 3D vector.\n   * @returns {Vector3D} The result 3D vector.\n   */\n  multiplyVector3D(vector3D) {\n    const array3D = this.multiplyArray3D(\n      [vector3D.getX(), vector3D.getY(), vector3D.getZ()]\n    );\n    return new Vector3D(array3D[0], array3D[1], array3D[2]);\n  }\n\n  /**\n   * Multiply this matrix by a 3D point.\n   *\n   * @param {Point3D} point3D The input 3D point.\n   * @returns {Point3D} The result 3D point.\n   */\n  multiplyPoint3D(point3D) {\n    const array3D = this.multiplyArray3D(\n      [point3D.getX(), point3D.getY(), point3D.getZ()]\n    );\n    return new Point3D(array3D[0], array3D[1], array3D[2]);\n  }\n\n  /**\n   * Multiply this matrix by a 3D index.\n   *\n   * @param {Index} index3D The input 3D index.\n   * @returns {Index} The result 3D index.\n   */\n  multiplyIndex3D(index3D) {\n    const array3D = this.multiplyArray3D(index3D.getValues());\n    return new Index(array3D);\n  }\n\n  /**\n   * Get the index of the maximum in absolute value of a row.\n   *\n   * @param {number} row The row to get the maximum from.\n   * @returns {object} The {value,index} of the maximum.\n   */\n  getRowAbsMax(row) {\n    const values = [\n      Math.abs(this.get(row, 0)),\n      Math.abs(this.get(row, 1)),\n      Math.abs(this.get(row, 2))\n    ];\n    const absMax = Math.max.apply(null, values);\n    const index = values.indexOf(absMax);\n    return {\n      value: this.get(row, index),\n      index: index\n    };\n  }\n\n  /**\n   * Get the index of the maximum in absolute value of a column.\n   *\n   * @param {number} col The column to get the maximum from.\n   * @returns {object} The {value,index} of the maximum.\n   */\n  getColAbsMax(col) {\n    const values = [\n      Math.abs(this.get(0, col)),\n      Math.abs(this.get(1, col)),\n      Math.abs(this.get(2, col))\n    ];\n    const absMax = Math.max.apply(null, values);\n    const index = values.indexOf(absMax);\n    return {\n      value: this.get(index, col),\n      index: index\n    };\n  }\n\n  /**\n   * Get this matrix with only zero and +/- ones instead of the maximum.\n   *\n   * @returns {Matrix33} The simplified matrix.\n   */\n  asOneAndZeros() {\n    // TODO: This breaks at 45 degree angles\n    const res = [];\n    for (let j = 0; j < 3; ++j) {\n      const max = this.getRowAbsMax(j);\n      const sign = max.value > 0 ? 1 : -1;\n      for (let i = 0; i < 3; ++i) {\n        if (i === max.index) {\n          res.push(1 * sign);\n        } else {\n          res.push(0);\n        }\n      }\n    }\n    return new Matrix33(res);\n  }\n\n  /**\n   * Get the third column direction index of an orientation matrix.\n   *\n   * @returns {number} The index of the absolute maximum of the last column.\n   */\n  getThirdColMajorDirection() {\n    return this.getColAbsMax(2).index;\n  }\n\n  /**\n   * Get the values of the matrix as an array.\n   *\n   * @returns {number[]} The matrix.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n} // Matrix33\n\n/**\n * Get the inverse of an input 3*3 matrix.\n *\n * Ref:\n * - {@link https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_3_%C3%97_3_matrices},\n * - {@link https://github.com/willnode/N-Matrix-Programmer}.\n *\n * @param {Matrix33} m The input matrix.\n * @returns {Matrix33|undefined} The inverse matrix or undefined\n *   if the determinant is zero.\n */\nfunction getMatrixInverse(m) {\n  const m00 = m.get(0, 0);\n  const m01 = m.get(0, 1);\n  const m02 = m.get(0, 2);\n  const m10 = m.get(1, 0);\n  const m11 = m.get(1, 1);\n  const m12 = m.get(1, 2);\n  const m20 = m.get(2, 0);\n  const m21 = m.get(2, 1);\n  const m22 = m.get(2, 2);\n\n  const a1212 = m11 * m22 - m12 * m21;\n  const a2012 = m12 * m20 - m10 * m22;\n  const a0112 = m10 * m21 - m11 * m20;\n\n  let det = m00 * a1212 + m01 * a2012 + m02 * a0112;\n  if (det === 0) {\n    logger.warn('Cannot invert 3*3 matrix with zero determinant.');\n    return undefined;\n  }\n  det = 1 / det;\n\n  const values = [\n    det * a1212,\n    det * (m02 * m21 - m01 * m22),\n    det * (m01 * m12 - m02 * m11),\n    det * a2012,\n    det * (m00 * m22 - m02 * m20),\n    det * (m02 * m10 - m00 * m12),\n    det * a0112,\n    det * (m01 * m20 - m00 * m21),\n    det * (m00 * m11 - m01 * m10)\n  ];\n\n  return new Matrix33(values);\n}\n\n/**\n * Create a 3x3 identity matrix.\n *\n * @returns {Matrix33} The identity matrix.\n */\nexport function getIdentityMat33() {\n  /* eslint-disable @stylistic/js/array-element-newline */\n  return new Matrix33([\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1\n  ]);\n  /* eslint-enable @stylistic/js/array-element-newline */\n}\n\n/**\n * Check if a matrix is a 3x3 identity matrix.\n *\n * @param {Matrix33} mat33 The matrix to test.\n * @returns {boolean} True if identity.\n */\nexport function isIdentityMat33(mat33) {\n  return mat33.equals(getIdentityMat33());\n}\n","import {\n  Tag,\n  getTransferSyntaxUIDTag,\n  isSequenceDelimitationItemTag,\n  isItemDelimitationItemTag,\n  isAnyPixelDataTag,\n  hasAnyPixelDataElement\n} from './dicomTag.js';\nimport {\n  is32bitVLVR,\n  isCharSetStringVR,\n  transferSyntaxes,\n  transferSyntaxKeywords,\n  vrTypes,\n} from './dictionary.js';\nimport {\n  safeGet,\n  DataElement\n} from './dataElement.js';\nimport {DataReader} from './dataReader.js';\nimport {logger} from '../utils/logger.js';\n\n/**\n * List of DICOM data elements indexed via a 8 character string formed from\n * the group and element numbers.\n *\n * @typedef {Object<string, DataElement>} DataElements\n */\n\n/**\n * Get the version of the library.\n *\n * @returns {string} The version of the library.\n */\nexport function getDwvVersion() {\n  return '0.36.0';\n}\n\n/**\n * Get the version of the library as a Unique Identifier (UI),\n * meaning just numbers and dots.\n *\n * @returns {string} The UI version of the library.\n */\nexport function getDwvVersionUI() {\n  // replace beta with '.99'\n  return getDwvVersion().replace('-beta', '.99');\n}\n\n/**\n * Get the dwv UID prefix.\n * Issued by Medical Connections Ltd (www.medicalconnections.co.uk)\n *   on 25/10/2017.\n *\n * @returns {string} The dwv UID prefix.\n */\nexport function getDwvUIDPrefix() {\n  return '1.2.826.0.1.3680043.9.7278.1';\n}\n\n/**\n * Get the value of the ImplementationVersionName tag.\n *\n * @returns {string} The name.\n */\nexport function getImplementationVersionName() {\n  return 'DWV_' + getDwvVersion();\n}\n\n/**\n * Get the value of the ImplementationClassUID tag.\n *\n * @returns {string} The uid.\n */\nexport function getImplementationClassUID() {\n  return getDwvUIDPrefix() + '.' + getDwvVersionUI();\n}\n\n/**\n * Get the dwv version from the value of the\n *   ImplementationClassUID tag.\n *\n * @param {string} uid The uid.\n * @returns {string|undefined} The dwv version.\n */\nexport function getDwvVersionFromImplementationClassUID(uid) {\n  let version;\n  const dwvPrefix = getDwvUIDPrefix();\n  if (uid.startsWith(dwvPrefix)) {\n    // reverse getDwvVersionUI\n    version = uid.substring(dwvPrefix.length + 1).replace('.99', '-beta');\n  }\n  return version;\n}\n\n/**\n * Split a string version into parts.\n * The input version follows a 'm.n.p[-beta.q]' version sheme (related\n *   to semantic versioning).\n *\n * @param {string} version The version.\n * @returns {string[]} The splited version.\n */\nfunction splitVersion(version) {\n  const split = version.split('-');\n  let versions = [];\n  for (const s of split) {\n    versions = versions.concat(s.split('.'));\n  }\n  return versions;\n}\n\n/**\n * Compare versions.\n * The input versions follow a 'm.n.p[-beta.q]' version sheme (related\n *   to semantic versioning).\n *\n * @param {string} a The first version.\n * @param {string} b The second version.\n * @returns {number} >0 to sort a after b, <0 to sort a before b,\n *   0 to not change order.\n */\nexport function compareVersions(a, b) {\n  let res = 0;\n  const splitA = splitVersion(a);\n  const splitB = splitVersion(b);\n  for (let i = 0; i < 3; ++i) {\n    res = parseInt(splitA[i], 10) - parseInt(splitB[i], 10);\n    if (res !== 0) {\n      break;\n    }\n  }\n  // beta part\n  if (res === 0) {\n    const betaIndex = 4;\n    const betaA = splitA[betaIndex];\n    const betaB = splitB[betaIndex];\n    if (typeof betaA === 'undefined' &&\n      typeof betaB === 'undefined') {\n      res = 0;\n    } else if (typeof betaA === 'undefined' &&\n      typeof betaB !== 'undefined') {\n      res = 1;\n    } else if (typeof betaA !== 'undefined' &&\n      typeof betaB === 'undefined') {\n      res = -1;\n    } else {\n      res = parseInt(betaA, 10) - parseInt(betaB, 10);\n    }\n  }\n  return res;\n}\n\n/**\n * Check if a version in inside bounds (bounds inclusives).\n * The input version follows a 'm.n.p[-beta.q]' version sheme (related\n *   to semantic versioning).\n *\n * @param {string} version The version to check.\n * @param {string} min The minimum version.\n * @param {string} max The maximum version.\n * @returns {boolean} True if the version in inside the bounds.\n */\nexport function isVersionInBounds(version, min, max) {\n  const compareMin = compareVersions(version, min);\n  const compareMax = compareVersions(version, max);\n  return compareMin >= 0 && compareMax <= 0;\n}\n\n/**\n * Check that an input buffer includes the DICOM prefix 'DICM'\n *   after the 128 bytes preamble.\n *\n * Ref: [DICOM File Meta]{@link https://dicom.nema.org/medical/dicom/2022a/output/chtml/part10/chapter_7.html#sect_7.1}.\n *\n * @param {ArrayBuffer} buffer The buffer to check.\n * @returns {boolean} True if the buffer includes the prefix.\n */\nexport function hasDicomPrefix(buffer) {\n  // check size: typed array constructor will throw RangeError if\n  // byteOffset + length * TypedArray.BYTES_PER_ELEMENT > buffer.byteLength\n  if (buffer.byteLength < 132) {\n    return false;\n  }\n  const prefixArray = new Uint8Array(buffer, 128, 4);\n  const stringReducer = function (previous, current) {\n    return previous += String.fromCharCode(current);\n  };\n  return prefixArray.reduce(stringReducer, '') === 'DICM';\n}\n\n// Zero-width space (u200B)\n// @ts-ignore\nconst ZWS = String.fromCharCode('u200B');\n\n/**\n * Clean string: remove zero-width space ending and trim.\n * Warning: no tests are done on the input, will fail if\n *   null or undefined or not string.\n * Exported for tests only.\n *\n * @param {string} inputStr The string to clean.\n * @returns {string} The cleaned string.\n */\nexport function cleanString(inputStr) {\n  let res = inputStr;\n  // get rid of ending zero-width space\n  const lastIndex = inputStr.length - 1;\n  if (inputStr[lastIndex] === ZWS) {\n    res = inputStr.substring(0, lastIndex);\n  }\n  // trim spaces\n  res = res.trim();\n  // return\n  return res;\n}\n\n/**\n * Get the utfLabel (used by the TextDecoder) from a character set term.\n *\n * References:\n * - DICOM [Value Encoding]{@link http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/chapter_6.html},\n * - DICOM [Specific Character Set]{@link http://dicom.nema.org/medical/dicom/2022a/output/chtml/part03/sect_C.12.html#sect_C.12.1.1.2},\n * - [TextDecoder#Parameters]{@link https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/TextDecoder#Parameters}.\n *\n * @param {string} charSetTerm The DICOM character set.\n * @returns {string} The corresponding UTF label.\n */\nfunction getUtfLabel(charSetTerm) {\n  let label = 'utf-8';\n  if (charSetTerm === 'ISO_IR 100') {\n    label = 'iso-8859-1';\n  } else if (charSetTerm === 'ISO_IR 101') {\n    label = 'iso-8859-2';\n  } else if (charSetTerm === 'ISO_IR 109') {\n    label = 'iso-8859-3';\n  } else if (charSetTerm === 'ISO_IR 110') {\n    label = 'iso-8859-4';\n  } else if (charSetTerm === 'ISO_IR 144') {\n    label = 'iso-8859-5';\n  } else if (charSetTerm === 'ISO_IR 127') {\n    label = 'iso-8859-6';\n  } else if (charSetTerm === 'ISO_IR 126') {\n    label = 'iso-8859-7';\n  } else if (charSetTerm === 'ISO_IR 138') {\n    label = 'iso-8859-8';\n  } else if (charSetTerm === 'ISO_IR 148') {\n    label = 'iso-8859-9';\n  } else if (charSetTerm === 'ISO_IR 13') {\n    label = 'shift-jis';\n  } else if (charSetTerm === 'ISO_IR 166') {\n    label = 'iso-8859-11';\n  } else if (charSetTerm === 'ISO 2022 IR 87') {\n    label = 'iso-2022-jp';\n  } else if (charSetTerm === 'ISO 2022 IR 149') {\n    // not supported by TextDecoder when it says it should...\n    //label = \"iso-2022-kr\";\n  } else if (charSetTerm === 'ISO 2022 IR 58') {\n    // not supported by TextDecoder...\n    //label = \"iso-2022-cn\";\n  } else if (charSetTerm === 'ISO_IR 192') {\n    label = 'utf-8';\n  } else if (charSetTerm === 'GB18030') {\n    label = 'gb18030';\n  } else if (charSetTerm === 'GB2312') {\n    label = 'gb2312';\n  } else if (charSetTerm === 'GBK') {\n    label = 'chinese';\n  }\n  return label;\n}\n\n/**\n * Default text decoder.\n */\nclass DefaultTextDecoder {\n  /**\n   * Decode an input string buffer.\n   *\n   * @param {Uint8Array} buffer The buffer to decode.\n   * @returns {string} The decoded string.\n   */\n  decode(buffer) {\n    let result = '';\n    for (let i = 0, leni = buffer.length; i < leni; ++i) {\n      result += String.fromCharCode(buffer[i]);\n    }\n    return result;\n  }\n}\n\n/**\n * Get patient orientation label in the reverse direction.\n *\n * @param {string} ori Patient Orientation value.\n * @returns {string} Reverse Orientation Label.\n */\nexport function getReverseOrientation(ori) {\n  if (!ori) {\n    return null;\n  }\n  // reverse labels\n  const rlabels = {\n    L: 'R',\n    R: 'L',\n    A: 'P',\n    P: 'A',\n    H: 'F',\n    F: 'H'\n  };\n\n  let rori = '';\n  for (let n = 0; n < ori.length; n++) {\n    const o = ori.substring(n, n + 1);\n    const r = rlabels[o];\n    if (r) {\n      rori += r;\n    }\n  }\n  // return\n  return rori;\n}\n\n/**\n * Tell if a given syntax is an implicit one (element with no VR).\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if an implicit syntax.\n */\nexport function isImplicitTransferSyntax(syntax) {\n  return syntax === transferSyntaxKeywords.ImplicitVRLittleEndian;\n}\n\n/**\n * Tell if a given syntax is a big endian syntax.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if a big endian syntax.\n */\nexport function isBigEndianTransferSyntax(syntax) {\n  return syntax === transferSyntaxKeywords.ExplicitVRBigEndian;\n}\n\n/**\n * Tell if a given syntax is a JPEG baseline one.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if a jpeg baseline syntax.\n */\nexport function isJpegBaselineTransferSyntax(syntax) {\n  return syntax === transferSyntaxKeywords.JPEGBaseline8Bit ||\n    syntax === transferSyntaxKeywords.JPEGExtended12Bit;\n}\n\n/**\n * Tell if a given syntax is a JPEG Lossless one.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if a jpeg lossless syntax.\n */\nexport function isJpegLosslessTransferSyntax(syntax) {\n  return syntax === transferSyntaxKeywords.JPEGLossless ||\n    syntax === transferSyntaxKeywords.JPEGLosslessSV1;\n}\n\n/**\n * Tell if a given syntax is a JPEG 2000 one.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if a jpeg 2000 syntax.\n */\nexport function isJpeg2000TransferSyntax(syntax) {\n  return syntax.match(/1.2.840.10008.1.2.4.9/) !== null;\n}\n\n/**\n * Tell if a given syntax is a RLE (Run-length encoding) one.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if a RLE syntax.\n */\nfunction isRleTransferSyntax(syntax) {\n  return syntax === transferSyntaxKeywords.RLELossless;\n}\n\n/**\n * Tell if a given syntax needs decompression.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {string|undefined} The name of the decompression algorithm.\n */\nexport function getSyntaxDecompressionName(syntax) {\n  let algo;\n  if (isJpeg2000TransferSyntax(syntax)) {\n    algo = 'jpeg2000';\n  } else if (isJpegBaselineTransferSyntax(syntax)) {\n    algo = 'jpeg-baseline';\n  } else if (isJpegLosslessTransferSyntax(syntax)) {\n    algo = 'jpeg-lossless';\n  } else if (isRleTransferSyntax(syntax)) {\n    algo = 'rle';\n  }\n  return algo;\n}\n\n/**\n * Tell if a given syntax is supported for reading.\n *\n * @param {string} syntax The transfer syntax to test.\n * @returns {boolean} True if a supported syntax.\n */\nfunction isReadSupportedTransferSyntax(syntax) {\n  return (syntax === transferSyntaxKeywords.ImplicitVRLittleEndian ||\n    syntax === transferSyntaxKeywords.ExplicitVRLittleEndian ||\n    syntax === transferSyntaxKeywords.ExplicitVRBigEndian ||\n    isJpegBaselineTransferSyntax(syntax) ||\n    isJpegLosslessTransferSyntax(syntax) ||\n    isJpeg2000TransferSyntax(syntax) ||\n    isRleTransferSyntax(syntax));\n}\n\n/**\n * Get a transfer syntax name from its UID.\n *\n * @param {string} syntax The transfer syntax UID value.\n * @returns {string} The transfer syntax name.\n */\nexport function getTransferSyntaxName(syntax) {\n  let name = 'Unknown';\n  if (typeof transferSyntaxes[syntax] !== 'undefined') {\n    name = transferSyntaxes[syntax];\n  }\n  return name;\n}\n\n/**\n * Guess the transfer syntax from the first data element.\n *\n * See {@link https://github.com/ivmartel/dwv/issues/188}\n *   (Allow to load DICOM with no DICM preamble) for more details.\n *\n * @param {DataElement} firstDataElement The first data element\n *   of the DICOM header.\n * @returns {DataElement} The transfer syntax data element.\n */\nfunction guessTransferSyntax(firstDataElement) {\n  const oEightGroupBigEndian = '0800';\n  const oEightGroupLittleEndian = '0008';\n  // check that group is 0008\n  const group = firstDataElement.tag.getGroup();\n  if (group !== oEightGroupBigEndian &&\n    group !== oEightGroupLittleEndian) {\n    throw new Error(\n      'Not a valid DICOM file (invalid DICM word found' +\n      ' and first element not in 0008 group)'\n    );\n  }\n  // reasonable assumption: 2 uppercase characters => explicit vr\n  const vr = firstDataElement.vr;\n  const vr0 = vr.charCodeAt(0);\n  const vr1 = vr.charCodeAt(1);\n  const implicit = (vr0 >= 65 && vr0 <= 90 && vr1 >= 65 && vr1 <= 90)\n    ? false : true;\n  // guess transfer syntax\n  let syntax = null;\n  if (group === oEightGroupLittleEndian) {\n    if (implicit) {\n      syntax = transferSyntaxKeywords.ImplicitVRLittleEndian;\n    } else {\n      syntax = transferSyntaxKeywords.ExplicitVRLittleEndian;\n    }\n  } else {\n    if (implicit) {\n      // ImplicitVRBigEndian: impossible\n      throw new Error(\n        'Not a valid DICOM file (no magic DICM word found' +\n        'and implicit VR big endian detected)'\n      );\n    } else {\n      syntax = transferSyntaxKeywords.ExplicitVRBigEndian;\n    }\n  }\n  // set transfer syntax data element\n  const dataElement = new DataElement('UI');\n  dataElement.tag = getTransferSyntaxUIDTag();\n  dataElement.value = [syntax];\n  dataElement.vl = dataElement.value[0].length;\n  dataElement.startOffset = firstDataElement.startOffset;\n  dataElement.endOffset = dataElement.startOffset + dataElement.vl;\n\n  return dataElement;\n}\n\n/**\n * Get the appropriate TypedArray in function of arguments.\n *\n * @param {number} bitsAllocated The number of bites used to store\n *   the data: [8, 16, 32].\n * @param {number} pixelRepresentation The pixel representation,\n *   0:unsigned;1:signed.\n * @param {number} size The size of the new array.\n * @returns {Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array}\n *   The good typed array.\n */\nexport function getTypedArray(bitsAllocated, pixelRepresentation, size) {\n  let res = null;\n  try {\n    if (bitsAllocated === 1 || bitsAllocated === 8) {\n      if (pixelRepresentation === 0) {\n        res = new Uint8Array(size);\n      } else {\n        res = new Int8Array(size);\n      }\n    } else if (bitsAllocated === 16) {\n      if (pixelRepresentation === 0) {\n        res = new Uint16Array(size);\n      } else {\n        res = new Int16Array(size);\n      }\n    } else if (bitsAllocated === 32) {\n      if (pixelRepresentation === 0) {\n        res = new Uint32Array(size);\n      } else {\n        res = new Int32Array(size);\n      }\n    }\n  } catch (error) {\n    if (error instanceof RangeError) {\n      const powerOf2 = Math.floor(Math.log(size) / Math.log(2));\n      logger.error('Cannot allocate array of size: ' +\n        size + ' (>2^' + powerOf2 + ').');\n    }\n  }\n  return res;\n}\n\n/**\n * Get the number of bytes occupied by a data element prefix,\n *   (without its value).\n *\n * WARNING: this is valid for tags with a VR, if not sure use\n *   the 'isTagWithVR' function first.\n *\n * Reference:\n * - [Data Element explicit]{@link http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/chapter_7.html#table_7.1-1},\n * - [Data Element implicit]{@link http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_7.5.2.html#table_7.5-1}.\n *\n * ```\n * | Tag | VR  | VL | Value |\n * | 4   | 2   | 2  | X     | -> regular explicit: 8 + X\n * | 4   | 2+2 | 4  | X     | -> 32bit VL: 12 + X\n *\n * | Tag | VL | Value |\n * | 4   | 4  | X     | -> implicit (32bit VL): 8 + X\n *\n * | Tag | Len | Value |\n * | 4   | 4   | X     | -> item: 8 + X\n * ```\n *\n * @param {string} vr The Value Representation of the element.\n * @param {boolean} isImplicit Does the data use implicit VR?\n * @returns {number} The size of the element prefix.\n */\nexport function getDataElementPrefixByteSize(vr, isImplicit) {\n  return isImplicit ? 8 : is32bitVLVR(vr) ? 12 : 8;\n}\n\n/**\n * Is the input VR a known VR.\n *\n * @param {string} vr The vr to test.\n * @returns {boolean} True if known.\n */\nfunction isKnownVR(vr) {\n  const extraVrTypes = ['NONE', 'ox', 'xx', 'xs'];\n  const knownTypes = Object.keys(vrTypes).concat(extraVrTypes);\n  return knownTypes.includes(vr);\n}\n\n/**\n * Small list of used tag keys.\n */\nconst TagKeys = {\n  TransferSyntax: '00020010',\n  SpecificCharacterSet: '00080005',\n  Rows: '00280010',\n  Columns: '00280011',\n  NumberOfFrames: '00280008',\n  BitsAllocated: '00280100',\n  PixelRepresentation: '00280103',\n  PixelData: '7FE00010'\n};\n\n/**\n * DicomParser class.\n *\n * @example\n * import {DicomParser} from '//esm.sh/dwv';\n * // XMLHttpRequest onload callback\n * const onload = function (event) {\n *   // setup the dicom parser\n *   const dicomParser = new DicomParser();\n *   // parse the buffer\n *   dicomParser.parse(event.target.response);\n *   // get the dicom tags\n *   const tags = dicomParser.getDicomElements();\n *   // display the modality\n *   const div = document.getElementById('dwv');\n *   div.appendChild(document.createTextNode(\n *     'Modality: ' + tags['00080060'].value[0]\n *   ));\n * };\n * // DICOM file request\n * const request = new XMLHttpRequest();\n * const url = 'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm';\n * request.open('GET', url);\n * request.responseType = 'arraybuffer';\n * request.onload = onload;\n * request.send();\n */\nexport class DicomParser {\n\n  /**\n   * The list of DICOM elements.\n   *\n   * @type {DataElements}\n   */\n  #dataElements = {};\n\n  /**\n   * Default character set (optional).\n   *\n   * @type {string}\n   */\n  #defaultCharacterSet;\n\n  /**\n   * Default text decoder.\n   *\n   * @type {DefaultTextDecoder}\n   */\n  #defaultTextDecoder = new DefaultTextDecoder();\n\n  /**\n   * Special text decoder.\n   *\n   * @type {DefaultTextDecoder|TextDecoder}\n   */\n  #textDecoder = this.#defaultTextDecoder;\n\n  /**\n   * Decode an input string buffer using the default text decoder.\n   *\n   * @param {Uint8Array} buffer The buffer to decode.\n   * @returns {string} The decoded string.\n   */\n  #decodeString(buffer) {\n    return this.#defaultTextDecoder.decode(buffer);\n  }\n\n  /**\n   * Decode an input string buffer using the 'special' text decoder.\n   *\n   * @param {Uint8Array} buffer The buffer to decode.\n   * @returns {string} The decoded string.\n   */\n  #decodeSpecialString(buffer) {\n    return this.#textDecoder.decode(buffer);\n  }\n\n  /**\n   * Get the default character set.\n   *\n   * @returns {string} The default character set.\n   */\n  getDefaultCharacterSet() {\n    return this.#defaultCharacterSet;\n  }\n\n  /**\n   * Set the default character set.\n   *\n   * @param {string} characterSet The input character set.\n   */\n  setDefaultCharacterSet(characterSet) {\n    this.#defaultCharacterSet = characterSet;\n  }\n\n  /**\n   * Set the text decoder character set.\n   *\n   * @param {string} characterSet The input character set.\n   */\n  setDecoderCharacterSet(characterSet) {\n    /**\n     * The text decoder.\n     *\n     * Ref: {@link https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder}.\n     *\n     * @external TextDecoder\n     */\n    this.#textDecoder = new TextDecoder(characterSet);\n  }\n\n  // not using type DataElements since the typedef is not exported with the API\n\n  /**\n   * Get the DICOM data elements.\n   *\n   * @returns {Object<string, DataElement>} The data elements.\n   */\n  getDicomElements() {\n    return this.#dataElements;\n  }\n\n  /**\n   * Safely get an elements' first value from the parsed elements.\n   *\n   * @param {string} key The tag key as for example '00100020'.\n   * @returns {any|undefined} The elements' value or undefined.\n   */\n  safeGet(key) {\n    return safeGet(this.#dataElements, key);\n  }\n\n  /**\n   * Read a DICOM tag.\n   *\n   * @param {DataReader} reader The raw data reader.\n   * @param {number} offset The offset where to start to read.\n   * @returns {object} An object containing the tag and the end offset.\n   */\n  #readTag(reader, offset) {\n    // group\n    const group = reader.readHex(offset);\n    offset += Uint16Array.BYTES_PER_ELEMENT;\n    // element\n    const element = reader.readHex(offset);\n    offset += Uint16Array.BYTES_PER_ELEMENT;\n    // return\n    return {\n      tag: new Tag(group, element),\n      endOffset: offset\n    };\n  }\n\n  /**\n   * Read an item data element.\n   *\n   * @param {DataReader} reader The raw data reader.\n   * @param {number} offset The offset where to start to read.\n   * @param {boolean} implicit Is the DICOM VR implicit?\n   * @returns {object} The item data as a list of data elements.\n   */\n  #readItemDataElement(reader, offset, implicit) {\n    const itemData = {};\n\n    // read the first item\n    let item = this.#readDataElement(reader, offset, implicit);\n    offset = item.endOffset;\n\n    // exit if it is a sequence delimitation item\n    if (isSequenceDelimitationItemTag(item.tag)) {\n      return {\n        data: itemData,\n        endOffset: item.endOffset,\n        isSeqDelim: true\n      };\n    }\n\n    // store item (mainly to keep vl)\n    itemData[item.tag.getKey()] = {\n      tag: item.tag,\n      vr: 'NONE',\n      vl: item.vl,\n      undefinedLength: item.undefinedLength\n    };\n\n    if (!item.undefinedLength) {\n      // explicit VR item: read until the end offset\n      const endOffset = offset;\n      offset -= item.vl;\n      while (offset < endOffset) {\n        item = this.#readDataElement(reader, offset, implicit);\n        offset = item.endOffset;\n        itemData[item.tag.getKey()] = item;\n      }\n    } else {\n      // implicit VR item: read until the item delimitation item\n      let isItemDelim = false;\n      while (!isItemDelim) {\n        item = this.#readDataElement(reader, offset, implicit);\n        offset = item.endOffset;\n        isItemDelim = isItemDelimitationItemTag(item.tag);\n        if (!isItemDelim) {\n          itemData[item.tag.getKey()] = item;\n        }\n      }\n    }\n\n    return {\n      data: itemData,\n      endOffset: offset,\n      isSeqDelim: false\n    };\n  }\n\n  /**\n   * Read the pixel item data element.\n   * Ref: [Single frame fragments]{@link http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_A.4.html#table_A.4-1}.\n   *\n   * @param {DataReader} reader The raw data reader.\n   * @param {number} offset The offset where to start to read.\n   * @param {boolean} implicit Is the DICOM VR implicit?\n   * @returns {object} The item data as an array of data elements.\n   */\n  #readPixelItemDataElement(\n    reader, offset, implicit) {\n    const itemData = [];\n\n    // first item: basic offset table\n    let item = this.#readDataElement(reader, offset, implicit);\n    const offsetTableVl = item.vl;\n    offset = item.endOffset;\n\n    // read until the sequence delimitation item\n    let isSeqDelim = false;\n    while (!isSeqDelim) {\n      item = this.#readDataElement(reader, offset, implicit);\n      offset = item.endOffset;\n      isSeqDelim = isSequenceDelimitationItemTag(item.tag);\n      if (!isSeqDelim) {\n        // force pixel item vr to OB\n        item.vr = 'OB';\n        itemData.push(item);\n      }\n    }\n\n    return {\n      data: itemData,\n      endOffset: offset,\n      offsetTableVl: offsetTableVl\n    };\n  }\n\n  /**\n   * Read a DICOM data element.\n   *\n   * Reference: [DICOM VRs]{@link http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_6.2.html#table_6.2-1}.\n   *\n   * @param {DataReader} reader The raw data reader.\n   * @param {number} offset The offset where to start to read.\n   * @param {boolean} implicit Is the DICOM VR implicit?\n   * @param {Tag} [untilTag] Optional tag to stop the reading once reached,\n   *   the returned element will only contain the tag.\n   * @returns {DataElement} The data element.\n   */\n  #readDataElement(reader, offset, implicit, untilTag) {\n    // Tag: group, element\n    const readTagRes = this.#readTag(reader, offset);\n    const tag = readTagRes.tag;\n\n    if (typeof untilTag !== 'undefined' &&\n      tag.equals(untilTag)) {\n      const element = new DataElement('');\n      element.tag = tag;\n      return element;\n    }\n\n    offset = readTagRes.endOffset;\n\n    // Value Representation (VR)\n    let vr = null;\n    let is32bitVL = false;\n    if (tag.isWithVR()) {\n      // implicit VR\n      if (implicit) {\n        vr = tag.getVrFromDictionary();\n        if (typeof vr === 'undefined') {\n          vr = 'UN';\n        }\n        is32bitVL = true;\n      } else {\n        vr = this.#decodeString(reader.readUint8Array(offset, 2));\n        offset += 2 * Uint8Array.BYTES_PER_ELEMENT;\n        is32bitVL = is32bitVLVR(vr);\n        // reserved 2 bytes\n        if (is32bitVL) {\n          offset += 2 * Uint8Array.BYTES_PER_ELEMENT;\n        }\n      }\n    } else {\n      vr = 'NONE';\n      is32bitVL = true;\n    }\n\n    // check vr\n    if (!isKnownVR(vr)) {\n      logger.warn('Unknown VR: ' + vr +\n        ' (for tag ' + tag.getKey() + '), treating as \\'UN\\'');\n      vr = 'UN';\n    }\n\n    // Value Length (VL)\n    let vl = 0;\n    if (is32bitVL) {\n      vl = reader.readUint32(offset);\n      offset += Uint32Array.BYTES_PER_ELEMENT;\n    } else {\n      vl = reader.readUint16(offset);\n      offset += Uint16Array.BYTES_PER_ELEMENT;\n    }\n\n    // check the value of VL\n    let undefinedLength = false;\n    if (vl === 0xffffffff) {\n      undefinedLength = true;\n      vl = 0;\n    }\n\n    // treat private tag with unknown VR and zero VL as a sequence (see #799)\n    if (tag.isPrivate() && vr === 'UN' && vl === 0) {\n      vr = 'SQ';\n    }\n\n    let startOffset = offset;\n    let endOffset = startOffset + vl;\n\n    // read sequence elements\n    let data;\n    if (isAnyPixelDataTag(tag) && undefinedLength) {\n      // pixel data sequence (implicit)\n      const pixItemData =\n        this.#readPixelItemDataElement(reader, offset, implicit);\n      offset = pixItemData.endOffset;\n      startOffset += pixItemData.offsetTableVl;\n      data = pixItemData.data;\n      endOffset = offset;\n      vl = offset - startOffset;\n    } else if (vr === 'SQ') {\n      // sequence\n      data = [];\n      let itemData;\n      if (!undefinedLength) {\n        if (vl !== 0) {\n          // explicit VR sequence: read until the end offset\n          const sqEndOffset = offset + vl;\n          while (offset < sqEndOffset) {\n            itemData = this.#readItemDataElement(reader, offset, implicit);\n            data.push(itemData.data);\n            offset = itemData.endOffset;\n          }\n          endOffset = offset;\n          vl = offset - startOffset;\n        }\n      } else {\n        // implicit VR sequence: read until the sequence delimitation item\n        let isSeqDelim = false;\n        while (!isSeqDelim) {\n          itemData = this.#readItemDataElement(reader, offset, implicit);\n          isSeqDelim = itemData.isSeqDelim;\n          offset = itemData.endOffset;\n          // do not store the delimitation item\n          if (!isSeqDelim) {\n            data.push(itemData.data);\n          }\n        }\n        endOffset = offset;\n        vl = offset - startOffset;\n      }\n    }\n\n    // return\n    const element = new DataElement(vr);\n    element.tag = tag;\n    element.vl = vl;\n    element.startOffset = startOffset;\n    element.endOffset = endOffset;\n    // only set if true (only for sequences and items)\n    if (undefinedLength) {\n      element.undefinedLength = undefinedLength;\n    }\n    if (data) {\n      element.items = data;\n    }\n    return element;\n  }\n\n  /**\n   * Interpret the data of an element.\n   *\n   * @param {DataElement} element The data element.\n   * @param {DataReader} reader The raw data reader.\n   * @param {object} [pixelTags] Pixel data related tags.\n   * @returns {object} The interpreted data.\n   */\n  #interpretElement(element, reader, pixelTags) {\n\n    const tag = element.tag;\n    const vl = element.vl;\n    const vr = element.vr;\n    const offset = element.startOffset;\n\n    let bitsAllocated;\n    let pixelRepresentation;\n    if (typeof pixelTags !== 'undefined') {\n      bitsAllocated = pixelTags.bitsAllocated;\n      pixelRepresentation = pixelTags.pixelRepresentation;\n    }\n\n    // data\n    let data = null;\n    const vrType = vrTypes[vr];\n    if (isAnyPixelDataTag(tag)) {\n      if (element.undefinedLength) {\n        // implicit pixel data sequence\n        data = [];\n        for (let j = 0; j < element.items.length; ++j) {\n          data.push(this.#interpretElement(\n            element.items[j], reader, pixelTags));\n        }\n        // remove non parsed items\n        delete element.items;\n      } else {\n        // check bits allocated and VR\n        // https://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_A.2.html\n        if (bitsAllocated > 8 && vr === 'OB') {\n          logger.warn(\n            'Reading DICOM pixel data with bitsAllocated>8 and OB VR' +\n            ', treating as OW'\n          );\n          element.vr = 'OW';\n        }\n        // read\n        data = [];\n        if (bitsAllocated === 1) {\n          data.push(reader.readBinaryArray(\n            offset, vl, pixelTags.imageBufferSize));\n        } else if (bitsAllocated === 8) {\n          if (pixelRepresentation === 0) {\n            data.push(reader.readUint8Array(offset, vl));\n          } else {\n            data.push(reader.readInt8Array(offset, vl));\n          }\n        } else if (bitsAllocated === 16) {\n          if (pixelRepresentation === 0) {\n            data.push(reader.readUint16Array(offset, vl));\n          } else {\n            data.push(reader.readInt16Array(offset, vl));\n          }\n        } else if (bitsAllocated === 32) {\n          data.push(reader.readFloat32Array(offset, vl));\n        } else if (bitsAllocated === 64) {\n          data.push(reader.readFloat64Array(offset, vl));\n        } else {\n          throw new Error('Unsupported bits allocated: ' + bitsAllocated);\n        }\n      }\n    } else if (typeof vrType !== 'undefined') {\n      if (vrType === 'Uint8') {\n        data = reader.readUint8Array(offset, vl);\n      } else if (vrType === 'Uint16') {\n        data = reader.readUint16Array(offset, vl);\n        // keep as binary for 'O*' VR\n        if (vr[0] !== 'O') {\n          data = Array.from(data);\n        }\n      } else if (vrType === 'Uint32') {\n        data = reader.readUint32Array(offset, vl);\n        // keep as binary for 'O*' VR\n        if (vr[0] !== 'O') {\n          data = Array.from(data);\n        }\n      } else if (vrType === 'Uint64') {\n        data = reader.readUint64Array(offset, vl);\n      } else if (vrType === 'Int16') {\n        data = Array.from(reader.readInt16Array(offset, vl));\n      } else if (vrType === 'Int32') {\n        data = Array.from(reader.readInt32Array(offset, vl));\n      } else if (vrType === 'Int64') {\n        data = reader.readInt64Array(offset, vl);\n      } else if (vrType === 'Float32') {\n        data = Array.from(reader.readFloat32Array(offset, vl));\n      } else if (vrType === 'Float64') {\n        data = Array.from(reader.readFloat64Array(offset, vl));\n      } else if (vrType === 'string') {\n        const stream = reader.readUint8Array(offset, vl);\n        if (isCharSetStringVR(vr)) {\n          data = this.#decodeSpecialString(stream);\n        } else {\n          data = this.#decodeString(stream);\n        }\n        data = cleanString(data).split('\\\\');\n      } else {\n        throw new Error('Unknown VR type: ' + vrType);\n      }\n    } else if (vr === 'xx') {\n      // US or OW\n      data = Array.from(reader.readUint16Array(offset, vl));\n    } else if (vr === 'ox') {\n      // OB or OW\n      if (bitsAllocated === 8) {\n        if (pixelRepresentation === 0) {\n          data = Array.from(reader.readUint8Array(offset, vl));\n        } else {\n          data = Array.from(reader.readInt8Array(offset, vl));\n        }\n      } else {\n        if (pixelRepresentation === 0) {\n          data = Array.from(reader.readUint16Array(offset, vl));\n        } else {\n          data = Array.from(reader.readInt16Array(offset, vl));\n        }\n      }\n    } else if (vr === 'xs') {\n      // (US or SS) or (US or SS or OW)\n      if (pixelRepresentation === 0) {\n        data = Array.from(reader.readUint16Array(offset, vl));\n      } else {\n        data = Array.from(reader.readInt16Array(offset, vl));\n      }\n    } else if (vr === 'AT') {\n      // attribute\n      const raw = reader.readUint16Array(offset, vl);\n      data = [];\n      for (let i = 0, leni = raw.length; i < leni; i += 2) {\n        const stri = raw[i].toString(16);\n        const stri1 = raw[i + 1].toString(16);\n        let str = '(';\n        str += '0000'.substring(0, 4 - stri.length) + stri.toUpperCase();\n        str += ',';\n        str += '0000'.substring(0, 4 - stri1.length) + stri1.toUpperCase();\n        str += ')';\n        data.push(str);\n      }\n    } else if (vr === 'SQ') {\n      // sequence\n      data = [];\n      for (let k = 0; k < element.items.length; ++k) {\n        const item = element.items[k];\n        const itemData = {};\n        const keys = Object.keys(item);\n        let sqBitsAllocated = bitsAllocated;\n        let sqPixelRepresentation = pixelRepresentation;\n        for (let l = 0; l < keys.length; ++l) {\n          // check if local bitsAllocated\n          // (inside item loop to get interpreted value)\n          let dataElement = item[TagKeys.BitsAllocated];\n          if (typeof dataElement !== 'undefined' &&\n            typeof dataElement.value !== 'undefined') {\n            sqBitsAllocated = dataElement.value[0];\n          }\n          // check if local pixelRepresentation\n          // (inside item loop to get interpreted value)\n          dataElement = item[TagKeys.PixelRepresentation];\n          if (typeof dataElement !== 'undefined' &&\n            typeof dataElement.value !== 'undefined') {\n            sqPixelRepresentation = dataElement.value[0];\n          }\n          const sqPixelTags = {\n            bitsAllocated: sqBitsAllocated,\n            pixelRepresentation: sqPixelRepresentation\n          };\n          const subElement = item[keys[l]];\n          subElement.value = this.#interpretElement(\n            subElement, reader, sqPixelTags);\n          delete subElement.tag;\n          delete subElement.vl;\n          delete subElement.startOffset;\n          delete subElement.endOffset;\n          itemData[keys[l]] = subElement;\n        }\n        data.push(itemData);\n      }\n      // remove non parsed elements\n      delete element.items;\n    } else if (vr === 'NONE') {\n      // no VR -> no data\n      data = [];\n    } else {\n      logger.warn('Unknown VR: ' + vr +\n        ' (for tag ' + element.tag.getKey() + ')');\n      // empty data...\n      data = [];\n    }\n\n    return data;\n  }\n\n  /**\n   * Interpret the data of a list of elements.\n   *\n   * @param {DataElements} elements A list of data elements.\n   * @param {DataReader} reader The raw data reader.\n   * @param {object} [pixelTags] Pixel data related tags.\n   */\n  #interpret(elements, reader, pixelTags) {\n\n    const keys = Object.keys(elements);\n    for (let i = 0; i < keys.length; ++i) {\n      const element = elements[keys[i]];\n      if (typeof element.value === 'undefined') {\n        element.value = this.#interpretElement(\n          element, reader, pixelTags);\n      }\n      // delete interpretation specific properties\n      delete element.tag;\n      delete element.vl;\n      delete element.startOffset;\n      delete element.endOffset;\n    }\n  }\n\n  /**\n   * Parse a DICOM buffer.\n   * Fills in the member object 'dataElements'.\n   *\n   * @param {ArrayBuffer} buffer The input array buffer.\n   * @param {Tag} [untilTag] Optional tag to stop the parsing once reached.\n   */\n  parse(buffer, untilTag) {\n    let offset = 0;\n    let syntax = '';\n    let dataElement = null;\n    // default readers\n    const metaReader = new DataReader(buffer);\n    let dataReader = new DataReader(buffer);\n\n    // 128 -> 132: magic word\n    offset = 128;\n    const magicword = this.#decodeString(metaReader.readUint8Array(offset, 4));\n    offset += 4 * Uint8Array.BYTES_PER_ELEMENT;\n    if (magicword === 'DICM') {\n      // 0002, 0000: FileMetaInformationGroupLength (vr='UL')\n      dataElement = this.#readDataElement(metaReader, offset, false);\n      dataElement.value = this.#interpretElement(dataElement, metaReader);\n      // increment offset\n      offset = dataElement.endOffset;\n      // store the data element\n      this.#dataElements[dataElement.tag.getKey()] = dataElement;\n      // get meta length\n      const metaLength = dataElement.value[0];\n\n      // meta elements\n      const metaEnd = offset + metaLength;\n      while (offset < metaEnd) {\n        // get the data element\n        dataElement = this.#readDataElement(metaReader, offset, false);\n        offset = dataElement.endOffset;\n        // store the data element\n        this.#dataElements[dataElement.tag.getKey()] = dataElement;\n      }\n\n      // check the TransferSyntaxUID (has to be there!)\n      dataElement = this.#dataElements[TagKeys.TransferSyntax];\n      if (typeof dataElement === 'undefined') {\n        throw new Error('Not a valid DICOM file (no TransferSyntaxUID found)');\n      }\n      dataElement.value = this.#interpretElement(dataElement, metaReader);\n      syntax = dataElement.value[0];\n\n    } else {\n      logger.warn('Invalid DICM prefix (' + magicword +\n        '), trying to guess tansfer syntax.');\n      // read first element\n      dataElement = this.#readDataElement(dataReader, 0, false);\n      // guess transfer syntax\n      const tsElement = guessTransferSyntax(dataElement);\n      // store\n      this.#dataElements[tsElement.tag.getKey()] = tsElement;\n      syntax = tsElement.value[0];\n      // reset offset\n      offset = 0;\n    }\n\n    // check transfer syntax support\n    if (!isReadSupportedTransferSyntax(syntax)) {\n      throw new Error('Unsupported DICOM transfer syntax: \\'' + syntax +\n        '\\' (' + getTransferSyntaxName(syntax) + ')');\n    }\n\n    // set implicit flag\n    let implicit = false;\n    if (isImplicitTransferSyntax(syntax)) {\n      implicit = true;\n    }\n\n    // Big Endian\n    if (isBigEndianTransferSyntax(syntax)) {\n      dataReader = new DataReader(buffer, false);\n    }\n\n    let reachedUntilTag = false;\n\n    // DICOM data elements\n    while (offset < buffer.byteLength) {\n      // get the data element\n      dataElement = this.#readDataElement(\n        dataReader, offset, implicit, untilTag);\n      // until tag\n      if (typeof untilTag !== 'undefined' &&\n        dataElement.tag.equals(untilTag)) {\n        reachedUntilTag = true;\n        break;\n      }\n      // increment offset\n      offset = dataElement.endOffset;\n      // store the data element\n      const key = dataElement.tag.getKey();\n      if (typeof this.#dataElements[key] === 'undefined') {\n        this.#dataElements[key] = dataElement;\n      } else {\n        logger.warn('Not saving duplicate tag: ' + key);\n      }\n    }\n\n    // safety checks...\n    if (isNaN(offset)) {\n      throw new Error('Problem while parsing, bad offset');\n    }\n    if (!reachedUntilTag && buffer.byteLength !== offset) {\n      logger.warn('Did not reach the end of the buffer: ' +\n        offset + ' != ' + buffer.byteLength);\n    }\n\n    //-------------------------------------------------\n    // values needed for data interpretation\n\n    // pixel specific\n    let pixelTags;\n    if (hasAnyPixelDataElement(this.#dataElements)) {\n      // PixelRepresentation 0->unsigned, 1->signed\n      let pixelRepresentation = 0;\n      dataElement = this.#dataElements[TagKeys.PixelRepresentation];\n      if (typeof dataElement !== 'undefined') {\n        dataElement.value = this.#interpretElement(dataElement, dataReader);\n        pixelRepresentation = dataElement.value[0];\n      } else {\n        logger.warn(\n          'Reading DICOM pixel data with default pixelRepresentation.');\n      }\n\n      // BitsAllocated\n      let bitsAllocated = 16;\n      dataElement = this.#dataElements[TagKeys.BitsAllocated];\n      if (typeof dataElement !== 'undefined') {\n        dataElement.value = this.#interpretElement(dataElement, dataReader);\n        bitsAllocated = dataElement.value[0];\n      } else {\n        logger.warn('Reading DICOM pixel data with default bitsAllocated.');\n      }\n\n      // NumberOfFrames\n      let numberOfFrames = 1;\n      dataElement = this.#dataElements[TagKeys.NumberOfFrames];\n      if (typeof dataElement !== 'undefined') {\n        dataElement.value = this.#interpretElement(dataElement, dataReader);\n        numberOfFrames = parseInt(dataElement.value[0], 10);\n      }\n\n      pixelTags = {\n        pixelRepresentation,\n        bitsAllocated,\n        numberOfFrames\n      };\n\n      // image buffer size\n      let rows;\n      dataElement = this.#dataElements[TagKeys.Rows];\n      if (typeof dataElement !== 'undefined') {\n        dataElement.value = this.#interpretElement(dataElement, dataReader);\n        rows = parseInt(dataElement.value[0], 10);\n      }\n      let cols;\n      dataElement = this.#dataElements[TagKeys.Columns];\n      if (typeof dataElement !== 'undefined') {\n        dataElement.value = this.#interpretElement(dataElement, dataReader);\n        cols = parseInt(dataElement.value[0], 10);\n      }\n      if (typeof rows !== 'undefined' &&\n        typeof cols !== 'undefined') {\n        pixelTags['imageBufferSize'] = rows * cols * numberOfFrames;\n      }\n    }\n\n    // default character set\n    if (typeof this.#defaultCharacterSet !== 'undefined') {\n      this.setDecoderCharacterSet(this.#defaultCharacterSet);\n    }\n\n    // SpecificCharacterSet\n    dataElement = this.#dataElements[TagKeys.SpecificCharacterSet];\n    if (typeof dataElement !== 'undefined') {\n      dataElement.value = this.#interpretElement(dataElement, dataReader);\n      let charSetTerm;\n      if (dataElement.value.length === 1) {\n        charSetTerm = dataElement.value[0];\n      } else {\n        charSetTerm = dataElement.value[1];\n        logger.warn('Unsupported character set with code extensions: \\'' +\n          charSetTerm + '\\'.');\n      }\n      this.setDecoderCharacterSet(getUtfLabel(charSetTerm));\n    }\n\n    // interpret the dicom elements\n    this.#interpret(this.#dataElements, dataReader, pixelTags);\n\n    // handle fragmented pixel buffer\n    // Reference: http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_8.2.html\n    // (third note, \"Depending on the transfer syntax...\")\n    dataElement = this.#dataElements[TagKeys.PixelData];\n    if (typeof dataElement !== 'undefined') {\n      if (dataElement.undefinedLength) {\n        const numberOfFrames = pixelTags.numberOfFrames;\n        const pixItems = dataElement.value;\n        if (pixItems.length > 1 && pixItems.length > numberOfFrames) {\n          // concatenate pixel data items\n          // concat does not work on typed arrays\n          //this.pixelBuffer = this.pixelBuffer.concat( dataElement.data );\n          // manual concat...\n          const nItemPerFrame = pixItems.length / numberOfFrames;\n          const newPixItems = [];\n          let index = 0;\n          for (let f = 0; f < numberOfFrames; ++f) {\n            index = f * nItemPerFrame;\n            // calculate the size of a frame\n            let size = 0;\n            for (let i = 0; i < nItemPerFrame; ++i) {\n              size += pixItems[index + i].length;\n            }\n            // create new buffer\n            const newBuffer = new pixItems[0].constructor(size);\n            // fill new buffer\n            let fragOffset = 0;\n            for (let j = 0; j < nItemPerFrame; ++j) {\n              newBuffer.set(pixItems[index + j], fragOffset);\n              fragOffset += pixItems[index + j].length;\n            }\n            newPixItems[f] = newBuffer;\n          }\n          // store as pixel data\n          dataElement.value = newPixItems;\n        }\n      }\n    }\n  }\n\n} // class DicomParser\n","\nimport {Matrix33, BIG_EPSILON} from '../math/matrix.js';\nimport {getTypedArray} from '../dicom/dicomParser.js';\n\n/**\n * Resampling file class.\n */\nexport class ResamplingFilter {\n  /**\n   * Simple trilinear sampling function.\n   *\n   * @param {number[]} point The index space point to sample.\n   * @param {TypedArray} buffer The buffer to sample.\n   * @param {number[]} size The buffer size.\n   * @param {number[]} unitVectors The buffer offset space unit vectors.\n   * @param {number} startOffset The offset to add to all sampled points.\n   * @returns {number} The sampled value.\n   */\n  #trilinearSample(point, buffer, size, unitVectors, startOffset) {\n    // base point\n    const q0x = Math.floor(point[0]);\n    const q0y = Math.floor(point[1]);\n    const q0z = Math.floor(point[2]);\n\n    // bounding points indices\n    const x0 = q0x < 0 ? 0 : q0x;\n    const x1 = q0x + 1 >= size[0] ? q0x : q0x + 1;\n    const y0 = q0y < 0 ? 0 : q0y;\n    const y1 = q0y + 1 >= size[1] ? q0y : q0y + 1;\n    const z0 = q0z < 0 ? 0 : q0z;\n    const z1 = q0z + 1 >= size[2] ? q0z : q0z + 1;\n\n    // bounding points offsets\n    const x0v = x0 * unitVectors[0];\n    const x1v = x1 * unitVectors[0];\n    const y0v = y0 * unitVectors[1];\n    const y1v = y1 * unitVectors[1];\n    const z0v = z0 * unitVectors[2];\n    const z1v = z1 * unitVectors[2];\n    const off000 = x0v + y0v + z0v + startOffset;\n    const off001 = x0v + y0v + z1v + startOffset;\n    const off010 = x0v + y1v + z0v + startOffset;\n    const off011 = x0v + y1v + z1v + startOffset;\n    const off100 = x1v + y0v + z0v + startOffset;\n    const off101 = x1v + y0v + z1v + startOffset;\n    const off110 = x1v + y1v + z0v + startOffset;\n    const off111 = x1v + y1v + z1v + startOffset;\n\n    // bounding points values\n    const x0ok = x0 >= 0 && x0 < size[0];\n    const x1ok = x1 >= 0 && x1 < size[0];\n    const y0ok = y0 >= 0 && y0 < size[1];\n    const y1ok = y1 >= 0 && y1 < size[1];\n    const z0ok = z0 >= 0 && z0 < size[2];\n    const z1ok = z1 >= 0 && z1 < size[2];\n    const v000 = (x0ok && y0ok && z0ok) ? buffer[off000] : 0;\n    const v001 = (x0ok && y0ok && z1ok) ? buffer[off001] : 0;\n    const v010 = (x0ok && y1ok && z0ok) ? buffer[off010] : 0;\n    const v011 = (x0ok && y1ok && z1ok) ? buffer[off011] : 0;\n    const v100 = (x1ok && y0ok && z0ok) ? buffer[off100] : 0;\n    const v101 = (x1ok && y0ok && z1ok) ? buffer[off101] : 0;\n    const v110 = (x1ok && y1ok && z0ok) ? buffer[off110] : 0;\n    const v111 = (x1ok && y1ok && z1ok) ? buffer[off111] : 0;\n\n    // interpolation weights\n    const wx0 = Math.abs(point[0] - q0x);\n    const wy0 = Math.abs(point[1] - q0y);\n    const wz0 = Math.abs(point[2] - q0z);\n    const wx1 = 1 - wx0;\n    const wy1 = 1 - wy0;\n    const wz1 = 1 - wz0;\n    // per point\n    const w000 = wx1 * wy1 * wz1;\n    const w001 = wx1 * wy1 * wz0;\n    const w010 = wx1 * wy0 * wz1;\n    const w011 = wx1 * wy0 * wz0;\n    const w100 = wx0 * wy1 * wz1;\n    const w101 = wx0 * wy1 * wz0;\n    const w110 = wx0 * wy0 * wz1;\n    const w111 = wx0 * wy0 * wz0;\n\n    // weighted sum\n    return (\n      v000 * w000 +\n      v001 * w001 +\n      v010 * w010 +\n      v011 * w011 +\n      v100 * w100 +\n      v101 * w101 +\n      v110 * w110 +\n      v111 * w111\n    );\n  }\n\n  /**\n   * Round if the value is close enough to an integer.\n   *\n   * @param {number} value The value to round.\n   * @returns {number} The rounded value.\n   */\n  #snapRound(value) {\n    const rounded = Math.round(value);\n    return Math.abs(value - rounded) < BIG_EPSILON ? rounded : value;\n  }\n\n  /**\n   * Generate the buffer for the resampled frame.\n   *\n   * @param {TypedArray} sourceImageBuffer The current image buffer.\n   * @param {number} pixelRepresentation The source image pixel representation.\n   * @param {number[]} targetSize The size of the target.\n   * @param {number[]} targetUnitVectors The buffer offset space unit vectors.\n   *\n   * @returns {TypedArray} The new buffer.\n   */\n  #generateReturnBuffer(\n    sourceImageBuffer,\n    pixelRepresentation,\n    targetSize,\n    targetUnitVectors\n  ) {\n    const totalSize = targetUnitVectors[2] * targetSize[2];\n\n    const targetImageBuffer = getTypedArray(\n      sourceImageBuffer.BYTES_PER_ELEMENT * 8,\n      pixelRepresentation,\n      totalSize\n    );\n\n    if (targetImageBuffer === null) {\n      throw new Error('Cannot reallocate data for image resampling.');\n    }\n\n    targetImageBuffer.fill(0);\n\n    return targetImageBuffer;\n  }\n\n  /**\n   * Calculate the resampling.\n   *\n   * @param {object} workerMessage The worker message.\n   * @returns {object} The resampled data and metadata.\n   */\n  run(workerMessage) {\n    const sourceSize = workerMessage.sourceSize;\n    const targetSize = workerMessage.targetSize;\n    const sourceUnitVectors = workerMessage.sourceUnitVectors;\n    const targetUnitVectors = workerMessage.targetUnitVectors;\n    const sourceSpacing = workerMessage.sourceSpacing;\n    const targetSpacing = workerMessage.targetSpacing;\n\n    const sourceImageBuffer = workerMessage.sourceImageBuffer;\n    const pixelRepresentation = workerMessage.pixelRepresentation;\n\n    const targetImageBuffer = this.#generateReturnBuffer(\n      sourceImageBuffer,\n      pixelRepresentation,\n      targetSize,\n      targetUnitVectors\n    );\n\n    const sourceStartOffset = workerMessage.sourceStartOffset;\n    const targetStartOffset = workerMessage.targetStartOffset;\n    const interpolate = workerMessage.interpolate;\n\n    const jobId = workerMessage.jobId;\n    const frame = workerMessage.frame;\n\n    // Can't pass them in as matrixes, so we need to re-create them\n    const sourceMatrix = new Matrix33(workerMessage.sourceOrientation);\n    const targetMatrix = new Matrix33(workerMessage.targetOrientation);\n\n    const invSourceMatrix = sourceMatrix.getInverse();\n    const relativeMatrix = targetMatrix.multiply(invSourceMatrix);\n\n    const halfTargetSize = [\n      (targetSize[0] - 1) / 2.0,\n      (targetSize[1] - 1) / 2.0,\n      (targetSize[2] - 1) / 2.0\n    ];\n\n    const halfSourceSize = [\n      (sourceSize[0] - 1) / 2.0,\n      (sourceSize[1] - 1) / 2.0,\n      (sourceSize[2] - 1) / 2.0\n    ];\n\n    const centeredIndexPoint = new Array(3);\n    const rotIndexPoint = new Array(3);\n    const point = new Array(3);\n\n    let targetOffX, targetOffXY, targetOffset;\n    for (let x = 0; x < targetSize[0]; x++) {\n      centeredIndexPoint[0] = (x - halfTargetSize[0]) * targetSpacing[0];\n      targetOffX = targetUnitVectors[0] * x;\n      for (let y = 0; y < targetSize[1]; y++) {\n        centeredIndexPoint[1] = (y - halfTargetSize[1]) * targetSpacing[1];\n        targetOffXY = targetOffX + targetUnitVectors[1] * y;\n        for (let z = 0; z < targetSize[2]; z++) {\n          centeredIndexPoint[2] = (z - halfTargetSize[2]) * targetSpacing[2];\n\n          relativeMatrix.multiplyTypedArray3D(\n            centeredIndexPoint, rotIndexPoint\n          );\n\n          point[0] = this.#snapRound(\n            (rotIndexPoint[0] / sourceSpacing[0]) + halfSourceSize[0]\n          );\n          point[1] = this.#snapRound(\n            (rotIndexPoint[1] / sourceSpacing[1]) + halfSourceSize[1]\n          );\n          point[2] = this.#snapRound(\n            (rotIndexPoint[2] / sourceSpacing[2]) + halfSourceSize[2]\n          );\n\n          if (\n            point[0] >= 0 && point[0] < sourceSize[0] &&\n            point[1] >= 0 && point[1] < sourceSize[1] &&\n            point[2] >= 0 && point[2] < sourceSize[2]\n          ) {\n            targetOffset = targetOffXY + (targetUnitVectors[2] * z);\n\n            if (interpolate) {\n              // Bilinear\n              const sample = this.#trilinearSample(\n                point,\n                sourceImageBuffer,\n                sourceSize,\n                sourceUnitVectors,\n                sourceStartOffset\n              );\n              targetImageBuffer[targetOffset] = sample;\n\n            } else {\n              // Nearest Neighbor\n              const inOffset =\n                (sourceUnitVectors[0] * Math.round(point[0])) +\n                (sourceUnitVectors[1] * Math.round(point[1])) +\n                (sourceUnitVectors[2] * Math.round(point[2])) +\n                sourceStartOffset;\n\n              targetImageBuffer[targetOffset] =\n                workerMessage.sourceImageBuffer[inOffset];\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      targetImageBuffer: targetImageBuffer,\n      startOffset: targetStartOffset,\n      jobId: jobId,\n      frame: frame\n    };\n  }\n}","/**\n * Resampling filter worker.\n */\n\nimport {ResamplingFilter} from './resamplingFilter.js';\n\nself.addEventListener('message', function (event) {\n\n  const filter = new ResamplingFilter();\n  const ret = filter.run(event.data);\n  self.postMessage(ret);\n\n}, false);"],"names":["Vector3D","constructor","x","y","z","this","getX","getY","getZ","equals","rhs","toString","norm","Math","sqrt","crossProduct","vector3D","dotProduct","isCodirectional","Point3D","getValues","isSimilar","tol","getDistance","point3D","dx","dy","dz","getClosest","pointList","minIndex","minDist","i","length","dist","minus","Index","values","Error","every","val","isNaN","get","slice","canCompare","leni","compare","diffDims","push","add","dim","value","console","warn","next","previous","getWithNew2D","j","l","lenl","logger","levels","TRACE","DEBUG","INFO","WARN","ERROR","level","trace","msg","debug","info","error","BIG_EPSILON","Number","EPSILON","a","b","abs","Matrix33","row","col","getInverse","m","m00","m01","m02","m10","m11","m12","m20","m21","m22","a1212","a2012","a0112","det","getMatrixInverse","str","multiply","tmp","k","getAbs","multiplyArray3D","array3D","a0","a1","a2","Array","multiplyTypedArray3D","sourceArray","outArray","multiplyVector3D","multiplyPoint3D","multiplyIndex3D","index3D","getRowAbsMax","absMax","max","apply","index","indexOf","getColAbsMax","asOneAndZeros","res","sign","getThirdColMajorDirection","String","fromCharCode","ResamplingFilter","point","buffer","size","unitVectors","startOffset","q0x","floor","q0y","q0z","x0","x1","y0","y1","z0","z1","x0v","x1v","y0v","y1v","z0v","z1v","off000","off001","off010","off011","off100","off101","off110","off111","x0ok","x1ok","y0ok","y1ok","z0ok","z1ok","v000","v001","v010","v011","v100","v101","v110","v111","wx0","wy0","wz0","wx1","wy1","wz1","rounded","round","sourceImageBuffer","pixelRepresentation","targetSize","targetUnitVectors","totalSize","targetImageBuffer","bitsAllocated","Uint8Array","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","RangeError","powerOf2","log","getTypedArray","BYTES_PER_ELEMENT","fill","run","workerMessage","sourceSize","sourceUnitVectors","sourceSpacing","targetSpacing","sourceStartOffset","targetStartOffset","interpolate","jobId","frame","sourceMatrix","sourceOrientation","targetMatrix","targetOrientation","invSourceMatrix","relativeMatrix","halfTargetSize","halfSourceSize","centeredIndexPoint","rotIndexPoint","targetOffX","targetOffXY","targetOffset","sample","inOffset","self","addEventListener","event","ret","data","postMessage"],"ignoreList":[],"sourceRoot":""}