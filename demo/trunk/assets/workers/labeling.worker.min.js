class t{#t;#e;constructor(t,e){this.#t=t,this.#e=e}getX(){return this.#t}getY(){return this.#e}getValues(){return[this.#t,this.#e]}getCentroid(){return this}equals(t){return null!=t&&this.#t===t.getX()&&this.#e===t.getY()}toString(){return"("+this.#t+", "+this.#e+")"}getDistance(t){const e=this.#t-t.getX(),i=this.#e-t.getY();return Math.sqrt(e*e+i*i)}}class e{cleanBuffer(t){for(let e=0;e<t.length;e++)t[e]>=128&&(t[e]=t[e]-128)}#i(t,e,i){return e[0]*Math.round(t.getX()/i[0])+e[1]*Math.round(t.getY()/i[1])}#n(e,i,n,s,l){const o=s.getBegin(),r=s.getEnd(),h=s.getDeltaX(),g=Math.abs(s.getDeltaY());let a=2*g-h,d=o.getY();const c=o.getY()<r.getY()?1:-1;for(let s=o.getX();s<=r.getX();s++){const o=this.#i(new t(s,d),i,n)+i[2]*l;e[o]=e[o]+128,a>0&&(d+=c,a-=2*h),a+=2*g}}#s(e,i,n,s,l){const o=s.getBegin(),r=s.getEnd(),h=Math.abs(s.getDeltaX()),g=s.getDeltaY();let a=2*h-g,d=o.getX();const c=o.getX()<r.getX()?1:-1;for(let s=o.getY();s<=r.getY();s++){const o=this.#i(new t(d,s),i,n)+i[2]*l;e[o]=e[o]+128,a>0&&(d+=c,a-=2*g),a+=2*h}}#l(t,e,i,n,s){const l=n.getBegin(),o=n.getEnd();Math.abs(n.getDeltaY())<Math.abs(n.getDeltaX())?l.getX()<o.getX()?this.#n(t,e,i,n,s):this.#n(t,e,i,n.getFlipped(),s):l.getY()<o.getY()?this.#s(t,e,i,n,s):this.#s(t,e,i,n.getFlipped(),s)}drawDebugLines(t,e,i,n,s,l){Object.values(l).map((i=>{this.#l(t,e,n,i.major.line,i.zIndex),void 0!==i.minor&&this.#l(t,e,n,i.minor.line,i.zIndex)}))}}class i{#o;#r;constructor(t,e){this.#o=t,this.#r=e}getBegin(){return this.#o}getEnd(){return this.#r}equals(t){return null!==t&&this.getBegin().equals(t.getBegin())&&this.getEnd().equals(t.getEnd())}getDeltaX(){return this.getEnd().getX()-this.getBegin().getX()}getDeltaY(){return this.getEnd().getY()-this.getBegin().getY()}getLength(){return Math.sqrt(this.getDeltaX()*this.getDeltaX()+this.getDeltaY()*this.getDeltaY())}getWorldLength(t){let e=null;if(null!==t){const i=this.getDeltaX()*t.x,n=this.getDeltaY()*t.y;e=Math.sqrt(i*i+n*n)}return e}getMidpoint(){return this.getCentroid()}getCentroid(){return new t((this.getBegin().getX()+this.getEnd().getX())/2,(this.getBegin().getY()+this.getEnd().getY())/2)}getSlope(){return this.getDeltaY()/this.getDeltaX()}getIntercept(){return(this.getEnd().getX()*this.getBegin().getY()-this.getBegin().getX()*this.getEnd().getY())/this.getDeltaX()}getInclination(){return 180-180*Math.atan2(this.getDeltaY(),this.getDeltaX())/Math.PI}getFlipped(){return new i(this.#r,this.#o)}quantify(t){const e=t.get2DSpacing(),i=this.getWorldLength(e);let n;return null!==i&&(n={value:i,unit:t.getLengthUnit()}),{length:n}}}class n{#h;#g;#a;#d;#c(t){if(t<0)return t;let e=t;for(;this.#g[e]!==e;)e=this.#g[e];let i=t;for(;this.#g[i]!==i;){const t=this.#g[i];this.#g[i]=e,i=t}return e}#u(t,e){this.#g[this.#c(t)]=this.#c(e)}#f(t,e,i,n){void 0!==this.#h&&this.#h===n||(this.#h=n,this.#g=new Int32Array(n),this.#a=new Int32Array(n),this.#d=new Int32Array(n));for(let n=0;n<i[2];n++){let s=0;for(let l=0;l<i[0];l++)for(let o=0;o<i[1];o++){const r=e[0]*l+e[1]*o+e[2]*n;this.#g[r]=r,this.#a[r]=-1;const h=t[r];if(h>0){const g=r-e[0],a=r-e[1],d=r-e[2],c=r+e[0],u=r+e[1];let f=0;l>0&&(f=t[g]);let b=0;o>0&&(b=t[a]);let m=0;n>0&&(m=t[d]);let p=0;l<i[0]-1&&(p=t[c]);let X=0;o<i[1]-1&&(X=t[u]);let D=0;l>0&&(D=this.#a[g]);let Y=0;o>0&&(Y=this.#a[a]);let w=0;n>0&&(w=this.#a[d]),f!==h&&b!==h&&m!==h?this.#a[r]=r:f===h&&b!==h&&m!==h?this.#a[r]=this.#c(D):f!==h&&b===h&&m!==h?this.#a[r]=this.#c(Y):f!==h&&b!==h&&m===h?this.#a[r]=this.#c(w):f!==h&&b===h&&m===h?(this.#u(Y,w),this.#a[r]=this.#c(Y)):f===h&&b!==h&&m===h?(this.#u(D,w),this.#a[r]=this.#c(D)):f===h&&b===h&&m!==h?(this.#u(D,Y),this.#a[r]=this.#c(D)):f===h&&b===h&&m===h&&(this.#u(D,Y),this.#u(D,w),this.#a[r]=this.#c(D)),f===h&&b===h&&p===h&&X===h||(this.#d[e[2]*n+s]=r,s++)}}this.#d[e[2]*n+s]=-1}}#b(t,e){const i=new Array(e.length);let n=t,s=0;for(let t=e.length-1;t>0;--t)s=e[t],i[t]=Math.floor(n/s),n-=i[t]*s;return i[0]=n,i}#m(t,e,i){const n={};for(let i=0;i<this.#a.length;i++){const s=this.#c(this.#a[i]);if(s>=0){const l=this.#b(i,e),o=n[s];if(void 0===o){const e={};e[l[2]]=1,n[s]={id:t[i],sum:l,count:1,sliceCounts:e,maxZ:l[2],minZ:l[2]}}else o.sum[0]+=l[0],o.sum[1]+=l[1],o.sum[2]+=l[2],o.count++,void 0!==o.sliceCounts[l[2]]?o.sliceCounts[l[2]]++:o.sliceCounts[l[2]]=1,o.maxZ=Math.max(o.maxZ,l[2]),o.minZ=Math.min(o.minZ,l[2])}}const s={};for(const[t,e]of Object.entries(n)){const n=Array(e.sum.length).fill(0);for(let t=0;t<e.sum.length;t++)n[t]=e.sum[t]/e.count;const l=Object.entries(e.sliceCounts),o=(()=>{if(l.length>1){const t=l.reduce((([t,e],[i,n])=>n>e?[i,n]:[t,e]))[0];return Number(t)}return Number(l[0][0])})();s[t]={id:e.id,centroidIndex:n,count:e.count,largestSliceZ:o,height:(e.maxZ-e.minZ+1)*i[2]}}return s}#p(e,i,n){let s=0,l=0;return i[0]>i[1]?(l=e%i[0]/i[1],s=Math.floor(e/i[0])):(s=e%i[1]/i[0],l=Math.floor(e/i[1])),s*=n[0],l*=n[1],new t(s,l)}#X(t,e){return t>90-e&&t<90+e}#D(t,e,n,s,l){const o={};for(let r=0;r<n[2];r++){const n=e[2]*r;let h=0;for(;this.#d[n+h]>=0;){const g=this.#d[n+h],a=this.#c(this.#a[g]);if(void 0!==l[a]&&l[a].largestSliceZ===r){const l=g-n,h=this.#p(l,e,s);let d=0;for(;this.#d[n+d]>=0;){const l=this.#d[n+d];if(a===this.#c(this.#a[l])){const d=l-n,c=this.#p(d,e,s),u=new i(h,c),f=u.getLength(),b=o[a];(void 0===b||b.major.diameter<f)&&(o[a]={id:t[g],major:{diameter:f,line:u,offset1:g,offset2:l},zIndex:r})}d++}}h++}}for(const[t,n]of Object.entries(o)){const l=e[2]*n.zIndex,o=n.major.line.getInclination();let r=0;for(;this.#d[l+r]>=0;){const h=this.#d[l+r],g=this.#c(this.#a[h]);if(g.toString()!==t){r++;continue}const a=h-l,d=this.#p(a,e,s);let c=0;for(;this.#d[l+c]>=0;){const r=this.#d[l+c],a=this.#c(this.#a[r]);if(a.toString()===t&&g===a){const t=r-l,g=this.#p(t,e,s),a=new i(d,g),c=a.getInclination(),u=Math.abs(c-o),f=a.getLength(),b=this.#X(u,.5),m=void 0!==n.minor&&!this.#X(n.minor.angleDiff,.5)&&this.#X(u,10);(void 0===n.minor||n.minor.diameter<f&&m||n.minor.diameter<f&&b)&&(n.minor={diameter:f,line:a,offset1:h,offset2:r,angleDiff:u})}c++}r++}}return o}run(t){const i=t.imageBuffer,n=t.unitVectors,s=t.sizes,l=t.spacing,o=t.totalSize;new e,this.#f(i,n,s,o);const r=this.#m(i,n,l),h=this.#D(i,n,s,l,r);return{labels:Object.entries(r).map((([t,e])=>{if(void 0!==h[t]){const i=h[t];delete i.id,delete i.zIndex,delete i.major.line,i.minor&&delete i.minor.line,e.diameters=i}return e}))}}}self.addEventListener("message",(function(t){const e=new n;self.postMessage(e.run(t.data))}),!1);
//# sourceMappingURL=labeling.worker.min.js.map