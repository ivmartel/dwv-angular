{"version":3,"file":"assets/workers/labeling.worker.min.js","mappings":"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","sources":["webpack://dwv/./src/math/point.js","webpack://dwv/./src/image/labelingDebug.js","webpack://dwv/./src/math/line.js","webpack://dwv/./src/image/labelingFilter.js","webpack://dwv/./src/image/labeling.worker.js"],"sourcesContent":["import {isSimilar} from './matrix.js';\nimport {Vector3D} from './vector.js';\n\n/**\n * Immutable 2D point.\n */\nexport class Point2D {\n\n  /**\n   * X position.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y position.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * @param {number} x The X coordinate for the point.\n   * @param {number} y The Y coordinate for the point.\n   */\n  constructor(x, y) {\n    this.#x = x;\n    this.#y = y;\n  }\n\n  /**\n   * Get the X position of the point.\n   *\n   * @returns {number} The X position of the point.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y position of the point.\n   *\n   * @returns {number} The Y position of the point.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return [this.#x, this.#y];\n  }\n\n  /**\n   * Get the centroid of the point, ie itself.\n   *\n   * @returns {Point2D} The centroid point.\n   */\n  getCentroid() {\n    return this;\n  }\n\n  /**\n   * Check for Point2D equality.\n   *\n   * @param {Point2D} rhs The other point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      typeof rhs !== 'undefined' &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY();\n  }\n\n  /**\n   * Get a string representation of the Point2D.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#x + ', ' + this.#y + ')';\n  }\n\n  /**\n   * Get the distance to another Point2D.\n   *\n   * @param {Point2D} point2D The input point.\n   * @returns {number} Ths distance to the input point.\n   */\n  getDistance(point2D) {\n    const dx = this.#x - point2D.getX();\n    const dy = this.#y - point2D.getY();\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n} // Point2D class\n\n/**\n * Immutable 3D point.\n */\nexport class Point3D {\n\n  /**\n   * X position.\n   *\n   * @type {number}\n   */\n  #x;\n\n  /**\n   * Y position.\n   *\n   * @type {number}\n   */\n  #y;\n\n  /**\n   * Z position.\n   *\n   * @type {number}\n   */\n  #z;\n\n  /**\n   * @param {number} x The X coordinate for the point.\n   * @param {number} y The Y coordinate for the point.\n   * @param {number} z The Z coordinate for the point.\n   */\n  constructor(x, y, z) {\n    this.#x = x;\n    this.#y = y;\n    this.#z = z;\n  }\n\n  /**\n   * Get the X position of the point.\n   *\n   * @returns {number} The X position of the point.\n   */\n  getX() {\n    return this.#x;\n  }\n\n  /**\n   * Get the Y position of the point.\n   *\n   * @returns {number} The Y position of the point.\n   */\n  getY() {\n    return this.#y;\n  }\n\n  /**\n   * Get the Z position of the point.\n   *\n   * @returns {number} The Z position of the point.\n   */\n  getZ() {\n    return this.#z;\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return [this.#x, this.#y, this.#z];\n  }\n\n  /**\n   * Check for Point3D equality.\n   *\n   * @param {Point3D} rhs The other point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      this.#x === rhs.getX() &&\n      this.#y === rhs.getY() &&\n      this.#z === rhs.getZ();\n  }\n\n  /**\n   * Check for Point3D similarity.\n   *\n   * @param {Point3D} rhs The other point to compare to.\n   * @param {number} [tol] Optional number comparison tolerance,\n   *   defaults to Number.EPSILON.\n   * @returns {boolean} True if both points are similar.\n   */\n  isSimilar(rhs, tol) {\n    return rhs !== null &&\n      isSimilar(this.#x, rhs.getX(), tol) &&\n      isSimilar(this.#y, rhs.getY(), tol) &&\n      isSimilar(this.#z, rhs.getZ(), tol);\n  }\n\n  /**\n   * Get a string representation of the Point3D.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#x +\n      ', ' + this.#y +\n      ', ' + this.#z + ')';\n  }\n\n  /**\n   * Get the distance to another Point3D.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {number} Ths distance to the input point.\n   */\n  getDistance(point3D) {\n    return Math.sqrt(this.#getSquaredDistance(point3D));\n  }\n\n  /**\n   * Get the square of the distance between this and\n   * an input point. Used for sorting.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {number} The square of the distance.\n   */\n  #getSquaredDistance(point3D) {\n    const dx = this.#x - point3D.getX();\n    const dy = this.#y - point3D.getY();\n    const dz = this.#z - point3D.getZ();\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  /**\n   * Get the closest point to this in a Point3D list.\n   *\n   * @param {Point3D[]} pointList The list to check.\n   * @returns {number} The index of the closest point in the input list.\n   */\n  getClosest(pointList) {\n    let minIndex = 0;\n    // the order between squared distances and distances is the same\n    let minDist = this.#getSquaredDistance(pointList[minIndex]);\n    for (let i = 0; i < pointList.length; ++i) {\n      const dist = this.#getSquaredDistance(pointList[i]);\n      if (dist < minDist) {\n        minIndex = i;\n        minDist = dist;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * Get the difference to another Point3D.\n   *\n   * @param {Point3D} point3D The input point.\n   * @returns {Vector3D} The 3D vector from the input point to this one.\n   */\n  minus(point3D) {\n    return new Vector3D(\n      (this.#x - point3D.getX()),\n      (this.#y - point3D.getY()),\n      (this.#z - point3D.getZ()));\n  }\n\n} // Point3D class\n\n/**\n * Get an array find callback for an equal input point.\n *\n * @param {Point3D} point The point to compare to.\n * @returns {Function} A function that compares, using `equals`,\n *   its input point to the one given as input to this function.\n */\nexport function getEqualPoint3DFunction(point) {\n  return function (element) {\n    return element.equals(point);\n  };\n}\n\n/**\n * Immutable point.\n * Warning: the input array is NOT cloned, modifying it will\n *  modify the point values.\n */\nexport class Point {\n\n  /**\n   * Point values.\n   *\n   * @type {number[]}\n   */\n  #values;\n\n  /**\n   * @param {number[]} values The point values.\n   */\n  constructor(values) {\n    if (!values || typeof values === 'undefined') {\n      throw new Error('Cannot create point with no values.');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot create point with empty values.');\n    }\n    const valueCheck = function (val) {\n      return !isNaN(val);\n    };\n    if (!values.every(valueCheck)) {\n      throw new Error('Cannot create point with non number values.');\n    }\n    this.#values = values;\n  }\n\n  /**\n   * Get the point value at the given array index.\n   *\n   * @param {number} i The index to get.\n   * @returns {number} The value.\n   */\n  get(i) {\n    return this.#values[i];\n  }\n\n  /**\n   * Get the length of the point.\n   *\n   * @returns {number} The length.\n   */\n  length() {\n    return this.#values.length;\n  }\n\n  /**\n   * Get a string representation of the point.\n   *\n   * @returns {string} The point as a string.\n   */\n  toString() {\n    return '(' + this.#values.toString() + ')';\n  }\n\n  /**\n   * Get the values of this point.\n   *\n   * @returns {number[]} The array of values.\n   */\n  getValues() {\n    return this.#values.slice();\n  }\n\n  /**\n   * Check if the input point can be compared to this one.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {boolean} True if both points are comparable.\n   */\n  canCompare(rhs) {\n    // check input\n    if (!rhs) {\n      return false;\n    }\n    // check length\n    if (this.length() !== rhs.length()) {\n      return false;\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Check for Point equality.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {boolean} True if both points are equal.\n   */\n  equals(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return false;\n    }\n    // check values\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        return false;\n      }\n    }\n    // seems ok!\n    return true;\n  }\n\n  /**\n   * Compare points and return different dimensions.\n   *\n   * @param {Point} rhs The point to compare to.\n   * @returns {number[]} The list of different dimensions.\n   */\n  compare(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    // check values\n    const diffDims = [];\n    for (let i = 0, leni = this.length(); i < leni; ++i) {\n      if (this.get(i) !== rhs.get(i)) {\n        diffDims.push(i);\n      }\n    }\n    return diffDims;\n  }\n\n  /**\n   * Get the 3D part of this point.\n   *\n   * @returns {Point3D} The Point3D.\n   */\n  get3D() {\n    return new Point3D(this.get(0), this.get(1), this.get(2));\n  }\n\n  /**\n   * Add another point to this one.\n   *\n   * @param {Point} rhs The point to add.\n   * @returns {Point} The point representing the sum of both points.\n   */\n  add(rhs) {\n    // check if can compare\n    if (!this.canCompare(rhs)) {\n      return null;\n    }\n    const values = [];\n    const values0 = this.getValues();\n    const values1 = rhs.getValues();\n    for (let i = 0; i < values0.length; ++i) {\n      values.push(values0[i] + values1[i]);\n    }\n    return new Point(values);\n  }\n\n  /**\n   * Merge this point with a Point3D to create a new point.\n   *\n   * @param {Point3D} rhs The Point3D to merge with.\n   * @returns {Point} The merge result.\n   */\n  mergeWith3D(rhs) {\n    const values = this.getValues();\n    values[0] = rhs.getX();\n    values[1] = rhs.getY();\n    values[2] = rhs.getZ();\n    return new Point(values);\n  }\n\n} // Point class\n","import {Point2D} from '../math/point.js';\n\n// doc imports\n/* eslint-disable no-unused-vars */\nimport {Line} from '../math/line.js';\n/* eslint-enable no-unused-vars */\n\n/**\n * Helper for the LabelingFilter, provides a debug display for diameters and\n * contours.\n *\n * Temporary until a proper way of rendering them is added.\n */\nexport class LabelingDebug {\n\n  /**\n   * Cleans buffer of debug lines before calculations.\n   *\n   * @param {TypedArray} imageBuffer The image buffer to clean.\n   */\n  cleanBuffer(imageBuffer) {\n    for (let i = 0; i < imageBuffer.length; i++) {\n      if (imageBuffer[i] >= 128) {\n        imageBuffer[i] = imageBuffer[i] - 128;\n      }\n    }\n  }\n\n  /**\n   * Convert a slice local world coordinate to a slice local offset value.\n   *\n   * @param {Point2D} point Point on the slice, scaled.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} spacing The pixel spacing of the image.\n   *\n   * @returns {number} Offset relative to the offset at the start of the slice.\n   */\n  #sliceWorldToSliceOffset(point, unitVectors, spacing) {\n    const offset =\n      (unitVectors[0] * Math.round(point.getX() / spacing[0])) +\n      (unitVectors[1] * Math.round(point.getY() / spacing[1]));\n\n    return offset;\n  }\n\n  /**\n   * Draw a debug line segment of an angle less that 45 degrees.\n   * Points should be in slice world space.\n   *\n   * @param {TypedArray} imageBuffer The image buffer to draw debug lines on.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} spacing The pixel spacing of the image.\n   * @param {Line} line The line segment to plot.\n   * @param {number} z The slice index.\n   */\n  #plotLineLow(imageBuffer, unitVectors, spacing, line, z) {\n    const p0 = line.getBegin();\n    const p1 = line.getEnd();\n    const dx = line.getDeltaX();\n    const dy = Math.abs(line.getDeltaY());\n    let D = 2 * dy - dx;\n    let y = p0.getY();\n    const yi = (p0.getY() < p1.getY()) ? 1 : -1;\n\n    for (let x = p0.getX(); x <= p1.getX(); x++) {\n      const sliceOffset =\n        this.#sliceWorldToSliceOffset(new Point2D(x, y), unitVectors, spacing);\n      const offset = sliceOffset + (unitVectors[2] * z);\n      imageBuffer[offset] = imageBuffer[offset] + 128;\n\n      if (D > 0) {\n        y = y + yi;\n        D = D - 2 * dx;\n      }\n      D = D + 2 * dy;\n    }\n  }\n\n  /**\n   * Draw a debug line segment of an angle greater that 45 degrees.\n   * Points should be in slice world space.\n   *\n   * @param {TypedArray} imageBuffer The image buffer to draw debug lines on.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} spacing The pixel spacing of the image.\n   * @param {Line} line The line segment to plot.\n   * @param {number} z The slice index.\n   */\n  #plotLineHigh(imageBuffer, unitVectors, spacing, line, z) {\n    const p0 = line.getBegin();\n    const p1 = line.getEnd();\n    const dx = Math.abs(line.getDeltaX());\n    const dy = line.getDeltaY();\n    let D = 2 * dx - dy;\n    let x = p0.getX();\n    const xi = (p0.getX() < p1.getX()) ? 1 : -1;\n\n    for (let y = p0.getY(); y <= p1.getY(); y++) {\n      const sliceOffset =\n        this.#sliceWorldToSliceOffset(new Point2D(x, y), unitVectors, spacing);\n      const offset = sliceOffset + (unitVectors[2] * z);\n      imageBuffer[offset] = imageBuffer[offset] + 128;\n\n      if (D > 0) {\n        x = x + xi;\n        D = D - 2 * dy;\n      }\n      D = D + 2 * dx;\n    }\n  }\n\n  /**\n   * Draw a debug line segment.\n   * Points should be in slice world space.\n   *\n   * @param {TypedArray} imageBuffer The image buffer to draw debug lines on.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} spacing The pixel spacing of the image.\n   * @param {Line} line The line segment to plot.\n   * @param {number} z The slice index.\n   */\n  #plotPoints(imageBuffer, unitVectors, spacing, line, z) {\n    const p0 = line.getBegin();\n    const p1 = line.getEnd();\n    if (Math.abs(line.getDeltaY()) < Math.abs(line.getDeltaX())) {\n      if (p0.getX() < p1.getX()) {\n        this.#plotLineLow(\n          imageBuffer,\n          unitVectors,\n          spacing,\n          line,\n          z\n        );\n      } else {\n        this.#plotLineLow(\n          imageBuffer,\n          unitVectors,\n          spacing,\n          line.getFlipped(),\n          z\n        );\n      }\n    } else {\n      if (p0.getY() < p1.getY()) {\n        this.#plotLineHigh(\n          imageBuffer,\n          unitVectors,\n          spacing,\n          line,\n          z\n        );\n      } else {\n        this.#plotLineHigh(\n          imageBuffer,\n          unitVectors,\n          spacing,\n          line.getFlipped(),\n          z\n        );\n      }\n    }\n  }\n\n  /**\n   * Renders debug lines for contours and diameters.\n   * The pixel value of the debug lines are the segmentation label of the\n   * segment + 128.\n   *\n   * @param {TypedArray} imageBuffer The image buffer to draw debug lines on.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} sizes The image dimensions.\n   * @param {number[]} spacing The pixel spacing of the image.\n   * @param {TypedArray} borders The buffer containing the border pixel arrays.\n   * @param {object} maxDiameters The dictionary of calculated diameters.\n   */\n  drawDebugLines(\n    imageBuffer,\n    unitVectors,\n    sizes,\n    spacing,\n    borders,\n    maxDiameters\n  ) {\n    Object.values(maxDiameters).map((diameter) => {\n      this.#plotPoints(\n        imageBuffer,\n        unitVectors,\n        spacing,\n        diameter.major.line,\n        diameter.zIndex\n      );\n\n      if (typeof diameter.minor !== 'undefined') {\n        this.#plotPoints(\n          imageBuffer,\n          unitVectors,\n          spacing,\n          diameter.minor.line,\n          diameter.zIndex\n        );\n      }\n    });\n  }\n\n} //class LabelingDebug","import {Point2D} from './point.js';\nimport {\n  isSimilar,\n  REAL_WORLD_EPSILON,\n} from './matrix.js';\n\n// doc imports\n/* eslint-disable no-unused-vars */\nimport {ViewController} from '../app/viewController.js';\nimport {Scalar2D} from './scalar.js';\nimport {Value} from './value.js';\n/* eslint-enable no-unused-vars */\n\n/**\n * Line shape.\n */\nexport class Line {\n\n  /**\n   * Line begin point.\n   *\n   * @type {Point2D}\n   */\n  #begin;\n\n  /**\n   * Line end point.\n   *\n   * @type {Point2D}\n   */\n  #end;\n\n  /**\n   * @param {Point2D} begin A Point2D representing the beginning\n   *   of the line.\n   * @param {Point2D} end A Point2D representing the end of the line.\n   */\n  constructor(begin, end) {\n    this.#begin = begin;\n    this.#end = end;\n  }\n\n  /**\n   * Get the begin point of the line.\n   *\n   * @returns {Point2D} The beginning point of the line.\n   */\n  getBegin() {\n    return this.#begin;\n  }\n\n  /**\n   * Get the end point of the line.\n   *\n   * @returns {Point2D} The ending point of the line.\n   */\n  getEnd() {\n    return this.#end;\n  }\n\n  /**\n   * Check for equality.\n   *\n   * @param {Line} rhs The object to compare to.\n   * @returns {boolean} True if both objects are equal.\n   */\n  equals(rhs) {\n    return rhs !== null &&\n      this.getBegin().equals(rhs.getBegin()) &&\n      this.getEnd().equals(rhs.getEnd());\n  }\n\n  /**\n   * Get the line delta in the X direction.\n   *\n   * @returns {number} The delta in the X direction.\n   */\n  getDeltaX() {\n    return this.getEnd().getX() - this.getBegin().getX();\n  }\n\n  /**\n   * Get the line delta in the Y direction.\n   *\n   * @returns {number} The delta in the Y direction.\n   */\n  getDeltaY() {\n    return this.getEnd().getY() - this.getBegin().getY();\n  }\n\n  /**\n   * Get the length of the line.\n   *\n   * @returns {number} The length of the line.\n   */\n  getLength() {\n    return Math.sqrt(\n      this.getDeltaX() * this.getDeltaX() +\n      this.getDeltaY() * this.getDeltaY()\n    );\n  }\n\n  /**\n   * Get the length of the line according to a  spacing.\n   *\n   * @param {Scalar2D} spacing2D The 2D spacing.\n   * @returns {number} The length of the line with spacing\n   *  or null for null spacings.\n   */\n  getWorldLength(spacing2D) {\n    let wlen = null;\n    if (spacing2D !== null) {\n      const dxs = this.getDeltaX() * spacing2D.x;\n      const dys = this.getDeltaY() * spacing2D.y;\n      wlen = Math.sqrt(dxs * dxs + dys * dys);\n    }\n    return wlen;\n  }\n\n  /**\n   * Get the mid point of the line.\n   *\n   * @returns {Point2D} The mid point of the line.\n   * @deprecated Since v0.36, please use getCentroid instead.\n   */\n  getMidpoint() {\n    return this.getCentroid();\n  }\n\n  /**\n   * Get the centroid of the line.\n   *\n   * @returns {Point2D} THe centroid point.\n   */\n  getCentroid() {\n    return new Point2D(\n      (this.getBegin().getX() + this.getEnd().getX()) / 2,\n      (this.getBegin().getY() + this.getEnd().getY()) / 2\n    );\n  }\n\n  /**\n   * Get the slope of the line.\n   *\n   * @returns {number} The slope of the line.\n   */\n  getSlope() {\n    return this.getDeltaY() / this.getDeltaX();\n  }\n\n  /**\n   * Get the intercept of the line.\n   *\n   * @returns {number} The slope of the line.\n   */\n  getIntercept() {\n    return (\n      this.getEnd().getX() * this.getBegin().getY() -\n      this.getBegin().getX() * this.getEnd().getY()\n    ) / this.getDeltaX();\n  }\n\n  /**\n   * Get the inclination of the line.\n   *\n   * @returns {number} The inclination of the line.\n   */\n  getInclination() {\n    // tan(theta) = slope\n    const angle =\n      Math.atan2(this.getDeltaY(), this.getDeltaX()) * 180 / Math.PI;\n    // shift?\n    return 180 - angle;\n  }\n\n  /**\n   * Get a new line with the start and end flipped.\n   *\n   * @returns {Line} The new flipped line.\n   */\n  getFlipped() {\n    return new Line(this.#end, this.#begin);\n  }\n\n  /**\n   * Quantify a line according to view information.\n   *\n   * @param {ViewController} viewController The associated view controller.\n   * @returns {Object<string, Value>} A quantification object.\n   */\n  quantify(viewController) {\n    // length\n    const spacing2D = viewController.get2DSpacing();\n    const worldLength = this.getWorldLength(spacing2D);\n    let length;\n    if (worldLength !== null) {\n      length = {\n        value: worldLength,\n        unit: viewController.getLengthUnit()\n      };\n    }\n    // return\n    return {length};\n  }\n\n} // Line class\n\n/**\n * Get the angle between two lines in degree.\n *\n * @param {Line} line0 The first line.\n * @param {Line} line1 The second line.\n * @returns {number} The angle.\n */\nexport function getAngle(line0, line1) {\n  const dx0 = line0.getDeltaX();\n  const dy0 = line0.getDeltaY();\n  const dx1 = line1.getDeltaX();\n  const dy1 = line1.getDeltaY();\n  // dot = ||a||*||b||*cos(theta)\n  const dot = dx0 * dx1 + dy0 * dy1;\n  // cross = ||a||*||b||*sin(theta)\n  const det = dx0 * dy1 - dy0 * dx1;\n  // tan = sin / cos\n  const angle = Math.atan2(det, dot) * 180 / Math.PI;\n  // complementary angle\n  // shift?\n  return 360 - (180 - angle);\n}\n\n/**\n * Check if two lines are orthogonal.\n *\n * @param {Line} line0 The first line.\n * @param {Line} line1 The second line.\n * @returns {boolean} True if both lines are orthogonal.\n */\nexport function areOrthogonal(line0, line1) {\n  const dx0 = line0.getDeltaX();\n  const dy0 = line0.getDeltaY();\n  const dx1 = line1.getDeltaX();\n  const dy1 = line1.getDeltaY();\n  // dot = ||a||*||b||*cos(theta)\n  return (dx0 * dx1 + dy0 * dy1) === 0;\n}\n\n/**\n * Check if a point is in a line coordinate range.\n *\n * @param {Point2D} point The input point.\n * @param {Line} line The input line.\n * @returns {boolean} True if the input point is in the line coordinate range.\n */\nexport function isPointInLineRange(point, line) {\n  const minX = Math.min(line.getBegin().getX(), line.getEnd().getX());\n  const maxX = Math.max(line.getBegin().getX(), line.getEnd().getX());\n  const minY = Math.min(line.getBegin().getY(), line.getEnd().getY());\n  const maxY = Math.max(line.getBegin().getY(), line.getEnd().getY());\n  return point.getX() >= minX &&\n    point.getX() <= maxX &&\n    point.getY() >= minY &&\n    point.getY() <= maxY;\n}\n\n/**\n * Get a perpendicular line to an input one at a given point.\n *\n * @param {Line} line The line to be perpendicular to.\n * @param {Point2D} point The middle point of the perpendicular line.\n * @param {number} length The length of the perpendicular line.\n * @param {Scalar2D} [spacing] Optional image spacing, default to [1,1].\n * @returns {Line} The perpendicular line.\n */\nexport function getPerpendicularLine(line, point, length, spacing) {\n  if (typeof spacing === 'undefined') {\n    spacing = {x: 1, y: 1};\n  }\n  const sx2 = spacing.x * spacing.x;\n  const sy2 = spacing.y * spacing.y;\n  // a0 * a1 = -1 (in square space)\n  const perpSlope = -sx2 / (sy2 * line.getSlope());\n  // y0 = a1*x0 + b1 -> b1 = y0 - a1*x0\n  const prepIntercept = point.getY() - perpSlope * point.getX();\n  // return\n  return getLineFromEquation(perpSlope, prepIntercept, point, length, spacing);\n}\n\n/**\n * Get a perpendicular line to an input one at a given distance\n *   of its begin point.\n *\n * @param {Line} line The line to be perpendicular to.\n * @param {number} distance The distance to the input line begin point.\n * @param {number} length The length of the perpendicular line.\n * @param {Scalar2D} [spacing] Optional image spacing, default to [1,1].\n * @returns {Line} The perpendicular line.\n */\nexport function getPerpendicularLineAtDistance(\n  line, distance, length, spacing) {\n  // get a line along the input one and centered on begin point\n  const lineFromEq = getLineFromEquation(\n    line.getSlope(),\n    line.getIntercept(),\n    line.getBegin(),\n    distance,\n    spacing\n  );\n  // select the point on the input line\n  let startPoint;\n  if (isPointInLineRange(lineFromEq.getBegin(), line)) {\n    startPoint = lineFromEq.getBegin();\n  } else {\n    startPoint = lineFromEq.getEnd();\n  }\n  // use it as base for a perpendicular line\n  return getPerpendicularLine(line, startPoint, length, spacing);\n}\n\n/**\n * Get a line from an equation, a middle point and a length.\n *\n * @param {number} slope The line slope.\n * @param {number} intercept The line intercept.\n * @param {Point2D} point The middle point of the line.\n * @param {number} length The line length.\n * @param {Scalar2D} [spacing] Optional image spacing, default to [1,1].\n * @returns {Line} The resulting line.\n */\nexport function getLineFromEquation(slope, intercept, point, length, spacing) {\n  if (typeof spacing === 'undefined') {\n    spacing = {x: 1, y: 1};\n  }\n  // begin point\n  let beginX = 0;\n  let beginY = 0;\n  // end point\n  let endX = 0;\n  let endY = 0;\n\n  if (isSimilar(slope, 0, REAL_WORLD_EPSILON)) {\n    // slope = ~0 -> horizontal input line\n    beginX = point.getX() - length / (2 * spacing.x);\n    beginY = point.getY();\n    endX = point.getX() + length / (2 * spacing.x);\n    endY = point.getY();\n  } else if (Math.abs(slope) > 1e6) {\n    // slope = ~(+/-)Infinity -> vertical input line\n    beginX = point.getX();\n    beginY = point.getY() - length / (2 * spacing.y);\n    endX = point.getX();\n    endY = point.getY() + length / (2 * spacing.y);\n  } else {\n    const sx2 = spacing.x * spacing.x;\n    const sy2 = spacing.y * spacing.y;\n\n    // 1. [length] sx^2 * (x - x0)^2 + sy^2 * (y - y0)^2 = d^2\n    // 2. [slope] a = (y - y0) / (x - x0) -> y - y0 = a*(x - x0)\n    // ->  sx^2 * (x - x0)^2 + sy^2 * a^2 * (x - x0)^2 = d^2\n    // ->  (x - x0)^2 = d^2 / (sx^2 + sy^2 * a^2)\n    // -> x = x0 +- d / sqrt(sx^2 + sy^2 * a^2)\n\n    // length is the distance between begin and end,\n    // point is half way between both -> d = length / 2\n    const dx = length / (2 * Math.sqrt(sx2 + sy2 * slope * slope));\n\n    // begin point\n    beginX = point.getX() - dx;\n    beginY = slope * beginX + intercept;\n    // end point\n    endX = point.getX() + dx;\n    endY = slope * endX + intercept;\n  }\n  return new Line(\n    new Point2D(beginX, beginY),\n    new Point2D(endX, endY));\n}\n","import {LabelingDebug} from './labelingDebug.js';\nimport {Point2D} from '../math/point.js';\nimport {Line} from '../math/line.js';\n\n// Set this to true to show the debug contour and diameter display\nconst DIAMETER_DEBUG = false;\n\n/**\n * Filter for calculating labels.\n *\n * Labels a buffer using the Hoshen窶適opelman\n * algorithm to first label all of the connected components, then does\n * a second pass to count the number of voxels in each unique label.\n *\n * The Hoshen窶適opelman labelling is slightly modified to work with\n * non-binary 3D data, but is otherwise structured the same way.\n *\n * Ref: {@link https://en.wikipedia.org/wiki/Hoshen%E2%80%93Kopelman_algorithm}.\n */\nexport class LabelingFilter {\n  /**\n   * The last known image size.\n   *\n   * @type {number}\n   */\n  #lastKnownTotalSize;\n\n  /**\n   * A union-find (disjoint-set) representing the available labels.\n   *\n   * @type {Int32Array}\n   */\n  #unionFind;\n\n  /**\n   * A buffer containing the labels for each voxel.\n   *\n   * @type {Int32Array}\n   */\n  #labels;\n\n  /**\n   * A buffer containing a list of border pixels for each layer.\n   *\n   * @type {Int32Array}\n   */\n  #borders;\n\n  /**\n   * Union-find find operation.\n   * Ref: {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}.\n   *\n   * @param {number} label The label to find the root of.\n   * @returns {number} The root label.\n   */\n  #find(label) {\n    if (label < 0) {\n      return label;\n    }\n\n    // Find the root label\n    let currentLabel = label;\n    while (this.#unionFind[currentLabel] !== currentLabel) {\n      currentLabel = this.#unionFind[currentLabel];\n    }\n\n    // Do an update pass to make this faster next time\n    let updateLabel = label;\n    while (this.#unionFind[updateLabel] !== updateLabel) {\n      const newLabel = this.#unionFind[updateLabel];\n      this.#unionFind[updateLabel] = currentLabel;\n      updateLabel = newLabel;\n    }\n\n    return currentLabel;\n  }\n\n  /**\n   * Union-find union operation.\n   *\n   * @param {number} label1 The child label to union.\n   * @param {number} label2 The parent label to union.\n   */\n  #union(label1, label2) {\n    // This will break if a non-label (-1) get passed in\n    // however with the current implmentation this should never happen\n    this.#unionFind[this.#find(label1)] = this.#find(label2);\n  }\n\n  /**\n   * Label the buffer using the Hoshen窶適opelman algorithm.\n   *\n   * @param {TypedArray} buffer The image buffer to regenerate the labels for.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} sizes The image dimensions.\n   * @param {number} totalSize The total length of the buffer.\n   */\n  #regenerateLabels(buffer, unitVectors, sizes, totalSize) {\n    // If we are re-calcing the labels of the same sized image as last time we\n    // can save a little time on re-initializing memory. Makes it slightly\n    // faster to use a seperate worker object per segmentation, at the\n    // cost of extra memory.\n    if (typeof this.#lastKnownTotalSize === 'undefined' ||\n      this.#lastKnownTotalSize !== totalSize) {\n      // The size of the image has changed, we need to reinitialize everything.\n      this.#lastKnownTotalSize = totalSize;\n\n      // Performance trade-off means this can use a fair bit of memory\n      // on large images.\n      this.#unionFind = new Int32Array(totalSize);\n      this.#labels = new Int32Array(totalSize);\n      this.#borders = new Int32Array(totalSize);\n    }\n\n    // Generate the Hoshen窶適opelman labels\n    for (let z = 0; z < sizes[2]; z++) {\n\n      let borderOffset = 0;\n\n      for (let x = 0; x < sizes[0]; x++) {\n        for (let y = 0; y < sizes[1]; y++) {\n\n          const thisOffset =\n            (unitVectors[0] * x) +\n            (unitVectors[1] * y) +\n            (unitVectors[2] * z);\n\n          // Reset labels.\n          this.#unionFind[thisOffset] = thisOffset;\n          this.#labels[thisOffset] = -1;\n\n          const thisValue = buffer[thisOffset];\n\n          if (thisValue > 0) {\n            // Neighbor offsets\n            const xOffset = thisOffset - unitVectors[0];\n            const yOffset = thisOffset - unitVectors[1];\n            const zOffset = thisOffset - unitVectors[2];\n\n            const xOffsetp = thisOffset + unitVectors[0];\n            const yOffsetp = thisOffset + unitVectors[1];\n\n            // Neighbor values\n            let xValue = 0;\n            if (x > 0) {\n              xValue = buffer[xOffset];\n            };\n            let yValue = 0;\n            if (y > 0) {\n              yValue = buffer[yOffset];\n            };\n            let zValue = 0;\n            if (z > 0) {\n              zValue = buffer[zOffset];\n            };\n\n            let xValuep = 0;\n            if (x < sizes[0] - 1) {\n              xValuep = buffer[xOffsetp];\n            };\n            let yValuep = 0;\n            if (y < sizes[1] - 1) {\n              yValuep = buffer[yOffsetp];\n            };\n\n            // Neighbor labels\n            let xLabel = 0;\n            if (x > 0) {\n              xLabel = this.#labels[xOffset];\n            };\n            let yLabel = 0;\n            if (y > 0) {\n              yLabel = this.#labels[yOffset];\n            };\n            let zLabel = 0;\n            if (z > 0) {\n              zLabel = this.#labels[zOffset];\n            };\n\n            // No neighbors with matching values\n            if (\n              xValue !== thisValue &&\n              yValue !== thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#labels[thisOffset] = thisOffset; // Guaranteed unique label.\n\n            // One neighbor with matching values\n            } else if (\n              xValue === thisValue &&\n              yValue !== thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#labels[thisOffset] = this.#find(xLabel);\n            } else if (\n              xValue !== thisValue &&\n              yValue === thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#labels[thisOffset] = this.#find(yLabel);\n            } else if (\n              xValue !== thisValue &&\n              yValue !== thisValue &&\n              zValue === thisValue\n            ) {\n              this.#labels[thisOffset] = this.#find(zLabel);\n\n            // Two neighbor with matching values\n            } else if (\n              xValue !== thisValue &&\n              yValue === thisValue &&\n              zValue === thisValue\n            ) {\n              this.#union(yLabel, zLabel);\n              this.#labels[thisOffset] = this.#find(yLabel);\n            } else if (\n              xValue === thisValue &&\n              yValue !== thisValue &&\n              zValue === thisValue\n            ) {\n              this.#union(xLabel, zLabel);\n              this.#labels[thisOffset] = this.#find(xLabel);\n            } else if (\n              xValue === thisValue &&\n              yValue === thisValue &&\n              zValue !== thisValue\n            ) {\n              this.#union(xLabel, yLabel);\n              this.#labels[thisOffset] = this.#find(xLabel);\n\n            // All neighbors with matching values\n            } else if (\n              xValue === thisValue &&\n              yValue === thisValue &&\n              zValue === thisValue\n            ) {\n              this.#union(xLabel, yLabel);\n              this.#union(xLabel, zLabel);\n              this.#labels[thisOffset] = this.#find(xLabel);\n            }\n\n            // Border check\n            if (\n              xValue !== thisValue ||\n              yValue !== thisValue ||\n              xValuep !== thisValue ||\n              yValuep !== thisValue\n            ) {\n              this.#borders[(unitVectors[2] * z) + borderOffset] = thisOffset;\n              borderOffset++;\n            }\n          }\n        }\n      }\n\n      this.#borders[(unitVectors[2] * z) + borderOffset] = -1;\n\n    }\n  }\n\n  /**\n   * Convert an offset in memory to an index.\n   *\n   * @param {number} offset The offset to convert.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @returns {number[]} The index.\n   */\n  #offsetToIndex(offset, unitVectors) {\n    const values = new Array(unitVectors.length);\n    let off = offset;\n    let dimSize = 0;\n    for (let i = unitVectors.length - 1; i > 0; --i) {\n      dimSize = unitVectors[i];\n      values[i] = Math.floor(off / dimSize);\n      off = off - values[i] * dimSize;\n    }\n    values[0] = off;\n    return values;\n  }\n\n  /**\n   * Quantify labels: count items, calculate centroid, and calculate height.\n   *\n   * @param {TypedArray} buffer The image buffer to quantify the labels for.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} spacing The pixel spacing of the image.\n   *\n   * @returns {object} The dictionary of quantified labels.\n   */\n  #quantifyLabels(\n    buffer,\n    unitVectors,\n    spacing\n  ) {\n    const detailledInfos = {};\n\n    // Count the number of voxels per unique label,\n    // this has to be done as a second pass.\n    for (let o = 0; o < this.#labels.length; o++) {\n      const labelValue = this.#find(this.#labels[o]);\n\n      if (labelValue >= 0) {\n        const index = this.#offsetToIndex(o, unitVectors);\n        const info = detailledInfos[labelValue];\n        if (typeof info === 'undefined') {\n          const sliceCounts = {};\n          sliceCounts[index[2]] = 1;\n          detailledInfos[labelValue] = {\n            id: buffer[o],\n            sum: index,\n            count: 1,\n            sliceCounts: sliceCounts,\n            maxZ: index[2],\n            minZ: index[2]\n          };\n        } else {\n          info.sum[0] += index[0];\n          info.sum[1] += index[1];\n          info.sum[2] += index[2];\n          info.count++;\n          if (typeof info.sliceCounts[index[2]] !== 'undefined') {\n            info.sliceCounts[index[2]]++;\n          } else {\n            info.sliceCounts[index[2]] = 1;\n          }\n          info.maxZ = Math.max(info.maxZ, index[2]);\n          info.minZ = Math.min(info.minZ, index[2]);\n        }\n      }\n    }\n\n    const labelsInfo = {};\n\n    for (const [label, detailledInfo] of Object.entries(detailledInfos)) {\n      const index = Array(detailledInfo.sum.length).fill(0);\n      for (let d = 0; d < detailledInfo.sum.length; d++) {\n        index[d] = detailledInfo.sum[d] / detailledInfo.count;\n      }\n\n      const sliceCounts = Object.entries(detailledInfo.sliceCounts);\n      const largestSliceZ = (() => {\n        if (sliceCounts.length > 1) {\n          const largest =\n            sliceCounts\n              .reduce((\n                [largestSlice, largestCount],\n                [currentSlice, currentCount]\n              ) => {\n                if (currentCount > largestCount) {\n                  return [currentSlice, currentCount];\n                } else {\n                  return [largestSlice, largestCount];\n                }\n              })[0];\n          return Number(largest);\n        } else {\n          return Number(sliceCounts[0][0]);\n        }\n      })();\n\n      labelsInfo[label] = {\n        id: detailledInfo.id,\n        centroidIndex: index,\n        count: detailledInfo.count,\n        largestSliceZ: largestSliceZ,\n        height: (detailledInfo.maxZ - detailledInfo.minZ + 1) * spacing[2]\n      };\n    }\n\n    return labelsInfo;\n  }\n\n  /**\n   * Convert a slice local offset value to a slice local world coordinate.\n   *\n   * @param {number} sliceOffset Offset relative to the offset at the\n   * start of the slice.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} spacing The pixel spacing of the image.\n   *\n   * @returns {Point2D} Point on the slice, scaled.\n   */\n  #sliceOffsetToSliceWorld(sliceOffset, unitVectors, spacing) {\n    let x = 0;\n    let y = 0;\n    if (unitVectors[0] > unitVectors[1]) {\n      y = (sliceOffset % unitVectors[0]) / unitVectors[1];\n      x = Math.floor(sliceOffset / unitVectors[0]);\n    } else {\n      x = (sliceOffset % unitVectors[1]) / unitVectors[0];\n      y = Math.floor(sliceOffset / unitVectors[1]);\n    }\n\n    x = x * spacing[0];\n    y = y * spacing[1];\n\n    return new Point2D(x, y);\n  }\n\n  /**\n   * Check if an angle is reasonably close to 90 degrees.\n   *\n   * @param {number} angle The angle to test.\n   * @param {number} epsilon How close to 90 degrees it needs to be.\n   * @returns {boolean} Is the angle close enough to 90 degrees.\n   */\n  #goodPerpendicularAngle(angle, epsilon) {\n    return angle > (90 - epsilon) && angle < (90 + epsilon);\n  }\n\n  /**\n   * Calculate the major and minor (perpendicular) diameters of each segment.\n   *\n   * @param {TypedArray} buffer The image buffer to calculate diameters for.\n   * @param {number[]} unitVectors The unit vectors for index to offset\n   *  conversion.\n   * @param {number[]} sizes The image dimensions.\n   * @param {number[]} spacing The pixel spacing of the image.\n   * @param {object} labelInfos The quantified labelInfos of the segments.\n   *\n   * @returns {object} The dictionary of calculated diameters.\n   */\n  #calculateDiameters(\n    buffer,\n    unitVectors,\n    sizes,\n    spacing,\n    labelInfos\n  ) {\n    const maxDiameters = {};\n\n    // Get the major diameter\n    for (let z = 0; z < sizes[2]; z++) {\n      const zOffset = unitVectors[2] * z;\n\n      // TODO: It would be more efficient to calculate the convex hull, use\n      // rotating calipers to get antipodal points, and then calculate the\n      // major diameter from those.\n      // For now the naive way is fast enough for an initial implementation.\n\n      let borderOffset1 = 0;\n      while (this.#borders[zOffset + borderOffset1] >= 0) {\n        const offset1 = this.#borders[zOffset + borderOffset1];\n        const label1 = this.#find(this.#labels[offset1]);\n\n        // We only care about the diameter of the largest slice,\n        // we can skip everything else.\n        if (\n          typeof labelInfos[label1] !== 'undefined' &&\n          labelInfos[label1].largestSliceZ === z\n        ) {\n          const sliceOffset1 = offset1 - zOffset;\n          const slicePosition1 =\n            this.#sliceOffsetToSliceWorld(sliceOffset1, unitVectors, spacing);\n\n          let borderOffset2 = 0;\n          while (this.#borders[zOffset + borderOffset2] >= 0) {\n            const offset2 = this.#borders[zOffset + borderOffset2];\n            const label2 = this.#find(this.#labels[offset2]);\n\n            if (label1 === label2) {\n              const sliceOffset2 = offset2 - zOffset;\n              const slicePosition2 =\n                this.#sliceOffsetToSliceWorld(\n                  sliceOffset2,\n                  unitVectors,\n                  spacing\n                );\n\n              const sliceLine = new Line(slicePosition1, slicePosition2);\n              const distance = sliceLine.getLength();\n\n              const maxDiameter = maxDiameters[label1];\n              if (\n                typeof maxDiameter === 'undefined' ||\n                maxDiameter.major.diameter < distance\n              ) {\n                maxDiameters[label1] = {\n                  id: buffer[offset1],\n                  major: {\n                    diameter: distance,\n                    line: sliceLine,\n                    offset1: offset1,\n                    offset2: offset2,\n                  },\n                  zIndex: z\n                };\n              }\n            }\n\n            borderOffset2++;\n          }\n\n        }\n\n        borderOffset1++;\n      }\n    }\n\n    // Get the minor (perpendicular) diameter\n    for (const [label, diameter] of Object.entries(maxDiameters)) {\n      const zOffset = unitVectors[2] * diameter.zIndex;\n      const diameterLine = diameter.major.line;\n      const diameterAngle = diameterLine.getInclination();\n\n      // TODO: This could also be made faster by using a modified antipodal\n      // point algorithm that uses perpedicularity to the initial diameter\n      // instead of parallel tangents (we can't use the convex hull for this\n      // one, so the normal algorithm doesn't work).\n      // For now the naive way is fast enough for an initial implementation.\n\n      let borderOffset1 = 0;\n      while (this.#borders[zOffset + borderOffset1] >= 0) {\n        const offset1 = this.#borders[zOffset + borderOffset1];\n        const label1 = this.#find(this.#labels[offset1]);\n\n        if (label1.toString() !== label) {\n          borderOffset1++;\n          continue;\n        }\n\n        const sliceOffset1 = offset1 - zOffset;\n        const slicePosition1 =\n          this.#sliceOffsetToSliceWorld(sliceOffset1, unitVectors, spacing);\n\n        let borderOffset2 = 0;\n        while (this.#borders[zOffset + borderOffset2] >= 0) {\n          const offset2 = this.#borders[zOffset + borderOffset2];\n          const label2 = this.#find(this.#labels[offset2]);\n          if (label2.toString() === label && label1 === label2) {\n            const sliceOffset2 = offset2 - zOffset;\n            const slicePosition2 =\n              this.#sliceOffsetToSliceWorld(\n                sliceOffset2,\n                unitVectors,\n                spacing\n              );\n\n            // Check angle for perpendicularity\n            const sliceLine = new Line(slicePosition1, slicePosition2);\n            const angle = sliceLine.getInclination();\n\n            const angleDifference = Math.abs(angle - diameterAngle);\n\n            const distance = sliceLine.getLength();\n\n            const isGoodAngle =\n              this.#goodPerpendicularAngle(angleDifference, 0.5);\n\n            // If we can't find any angles close to 90 degrees then\n            // prioritize finding something remotely useable.\n            // This only really happens on very small/thin segments.\n            const isReasonableWithoutBetter =\n              typeof diameter.minor !== 'undefined' &&\n              (!this.#goodPerpendicularAngle(\n                diameter.minor.angleDiff,\n                0.5\n              )) &&\n              (this.#goodPerpendicularAngle(\n                angleDifference,\n                10\n              ));\n\n            if (\n              typeof diameter.minor === 'undefined' ||\n              (\n                diameter.minor.diameter < distance &&\n                isReasonableWithoutBetter\n              ) ||\n              (\n                diameter.minor.diameter < distance &&\n                isGoodAngle\n              )\n            ) {\n              diameter.minor = {\n                diameter: distance,\n                line: sliceLine,\n                offset1: offset1,\n                offset2: offset2,\n                angleDiff: angleDifference\n              };\n            }\n          }\n\n          borderOffset2++;\n        }\n\n        borderOffset1++;\n      }\n    }\n\n    return maxDiameters;\n  }\n\n  /**\n   * Run the filter.\n   *\n   * @param {object} data The input data.\n   * @returns {object[]} The list of quantified labels.\n   */\n  run(data) {\n    const imageBuffer = data.imageBuffer;\n    const unitVectors = data.unitVectors;\n    const sizes = data.sizes;\n    const spacing = data.spacing;\n    const totalSize = data.totalSize;\n\n    //TODO: This is temporary until a proper method of displaying\n    // them is implmented.\n    // ------\n    const debug = new LabelingDebug();\n    if (DIAMETER_DEBUG) {\n      debug.cleanBuffer(imageBuffer);\n    }\n    // ------\n\n    // generate labels\n    this.#regenerateLabels(\n      imageBuffer,\n      unitVectors,\n      sizes,\n      totalSize\n    );\n\n    // quantify labels\n    const labelsInfo = this.#quantifyLabels(\n      imageBuffer,\n      unitVectors,\n      spacing\n    );\n\n    // calculate diameters\n    const maxDiameters = this.#calculateDiameters(\n      imageBuffer,\n      unitVectors,\n      sizes,\n      spacing,\n      labelsInfo\n    );\n\n    //TODO: This is temporary until a proper method of displaying\n    // them is implmented.\n    // ------\n    if (DIAMETER_DEBUG) {\n      debug.drawDebugLines(\n        imageBuffer,\n        unitVectors,\n        sizes,\n        spacing,\n        this.#borders,\n        maxDiameters\n      );\n    }\n    // ------\n\n    // merge calculations\n    const mergedLabelsInfo =\n      Object.entries(labelsInfo).map(\n        ([label, labelInfo]) => {\n          if (typeof maxDiameters[label] !== 'undefined') {\n            const diameters = maxDiameters[label];\n\n            // Duplicate information\n            delete diameters.id;\n            delete diameters.zIndex;\n\n            // These are in weird units and aren't helpful to pass back\n            delete diameters.major.line;\n            if (diameters.minor) {\n              delete diameters.minor.line;\n            }\n\n            labelInfo.diameters = diameters;\n          }\n\n          return labelInfo;\n        }\n      );\n\n    const returnEvent = {\n      labels: mergedLabelsInfo,\n    };\n\n    //TODO: This is temporary until a proper method of displaying\n    // them is implmented.\n    // ------\n    if (DIAMETER_DEBUG) {\n      returnEvent.buffer = imageBuffer;\n    }\n    // ------\n\n    return returnEvent;\n  }\n} // class labelingFilter\n","/**\n * Labeling filter worker.\n */\n\nimport {LabelingFilter} from './labelingFilter.js';\n\nself.addEventListener('message', function (event) {\n\n  const filter = new LabelingFilter();\n  self.postMessage(filter.run(event.data));\n\n}, false);\n"],"names":["Point2D","constructor","x","y","this","getX","getY","getValues","getCentroid","equals","rhs","toString","getDistance","point2D","dx","dy","Math","sqrt","LabelingDebug","cleanBuffer","imageBuffer","i","length","point","unitVectors","spacing","round","line","z","p0","getBegin","p1","getEnd","getDeltaX","abs","getDeltaY","D","yi","offset","xi","getFlipped","drawDebugLines","sizes","borders","maxDiameters","Object","values","map","diameter","major","zIndex","minor","Line","begin","end","getLength","getWorldLength","spacing2D","wlen","dxs","dys","getMidpoint","getSlope","getIntercept","getInclination","atan2","PI","quantify","viewController","get2DSpacing","worldLength","value","unit","getLengthUnit","LabelingFilter","label","currentLabel","updateLabel","newLabel","label1","label2","buffer","totalSize","Int32Array","borderOffset","thisOffset","thisValue","xOffset","yOffset","zOffset","xOffsetp","yOffsetp","xValue","yValue","zValue","xValuep","yValuep","xLabel","yLabel","zLabel","Array","off","dimSize","floor","detailledInfos","o","labelValue","index","info","sliceCounts","id","sum","count","maxZ","minZ","max","min","labelsInfo","detailledInfo","entries","fill","d","largestSliceZ","largest","reduce","largestSlice","largestCount","currentSlice","currentCount","Number","centroidIndex","height","sliceOffset","angle","epsilon","labelInfos","borderOffset1","offset1","sliceOffset1","slicePosition1","borderOffset2","offset2","sliceOffset2","slicePosition2","sliceLine","distance","maxDiameter","diameterAngle","angleDifference","isGoodAngle","isReasonableWithoutBetter","angleDiff","run","data","labels","labelInfo","diameters","self","addEventListener","event","filter","postMessage"],"ignoreList":[],"sourceRoot":""}